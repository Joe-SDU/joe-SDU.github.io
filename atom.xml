<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe&#39;s blog</title>
  
  
  <link href="http://joe-sdu.top/atom.xml" rel="self"/>
  
  <link href="http://joe-sdu.top/"/>
  <updated>2020-11-18T03:55:23.094Z</updated>
  <id>http://joe-sdu.top/</id>
  
  <author>
    <name>Joe-sdu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划专题</title>
    <link href="http://joe-sdu.top/2020/11/18/ACM/acm-dp%E4%B8%93%E9%A2%98/"/>
    <id>http://joe-sdu.top/2020/11/18/ACM/acm-dp%E4%B8%93%E9%A2%98/</id>
    <published>2020-11-18T04:28:49.000Z</published>
    <updated>2020-11-18T03:55:23.094Z</updated>
    
    
    
    
    <category term="ACM专题" scheme="http://joe-sdu.top/categories/ACM%E4%B8%93%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>主定理的应用</title>
    <link href="http://joe-sdu.top/2020/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E4%B8%BB%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://joe-sdu.top/2020/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E4%B8%BB%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2020-11-15T10:43:16.000Z</published>
    <updated>2020-11-16T07:52:47.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为主定理"><a href="#何为主定理" class="headerlink" title="何为主定理?"></a>何为主定理?</h2><ul><li><input disabled="" type="checkbox"> Wikipedia对主定理的描述是:它提供了渐进大O表示许多由分治法得到的递推式的方法。详细介绍可以参考算法导论。<blockquote><p>Tips: 不是所有递推关系式都可以用主定理。</p></blockquote><a id="more"></a></li></ul><h2 id="主定理通常的应用情形"><a href="#主定理通常的应用情形" class="headerlink" title="主定理通常的应用情形"></a>主定理通常的应用情形</h2><ul><li>假设有递推式:<br>$$ T(n) = aT(\dfrac {n}{b})+f(n), 其中a\geq1, b&gt;1 $$<br>其中，n是问题的规模，a为子问题数量，\dfrac {n}{b}为每个子问题的规模, f(n)是除递归外额外的工作。那么主定理通常有以下形式:<table><thead><tr><th>递推关系式</th><th>时间复杂度</th></tr></thead><tbody><tr><td>$$T(n) = T(\dfrac {n}{2}) + \varTheta(1)$$</td><td>$$\varTheta(\log n)$$</td></tr><tr><td>$$T(n) = 2T(\dfrac {n}{2}) + \varTheta(1)$$</td><td>$$\varTheta(n)$$</td></tr><tr><td>$$T(n) = 2T(\dfrac {n}{2}) + O(\log n)$$</td><td>$$\varTheta(n)$$</td></tr><tr><td>$$T(n) = 2T(\dfrac {n}{2}) + \varTheta(n)$$</td><td>$$\varTheta(n\log n)$$</td></tr></tbody></table></li></ul><h2 id="参考文献和资料"><a href="#参考文献和资料" class="headerlink" title="参考文献和资料"></a>参考文献和资料</h2><ul><li>Wikipedia，2020年10月12日更新版。</li><li>算法导论。</li><li>Michael T. Goodrich and Roberto Tamassia. Algorithm Design: Foundation, Analysis, and Internet Examples. Wiley, 2002. ISBN 0-471-38365-1. The master theorem (including the version of Case 2 included here, which is stronger than the one from CLRS) is on pp. 268–270.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;何为主定理&quot;&gt;&lt;a href=&quot;#何为主定理&quot; class=&quot;headerlink&quot; title=&quot;何为主定理?&quot;&gt;&lt;/a&gt;何为主定理?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; Wikipedia对主定理的描述是:它提供了渐进大O表示许多由分治法得到的递推式的方法。详细介绍可以参考算法导论。&lt;blockquote&gt;
&lt;p&gt;Tips: 不是所有递推关系式都可以用主定理。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法习题答案(机械工业出版社)" scheme="http://joe-sdu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Latex介绍</title>
    <link href="http://joe-sdu.top/2020/11/15/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/latex/"/>
    <id>http://joe-sdu.top/2020/11/15/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/latex/</id>
    <published>2020-11-15T06:45:32.000Z</published>
    <updated>2020-11-15T14:03:03.641Z</updated>
    
    
    
    
    <category term="文本编辑工具" scheme="http://joe-sdu.top/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown介绍</title>
    <link href="http://joe-sdu.top/2020/11/15/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/markdown/"/>
    <id>http://joe-sdu.top/2020/11/15/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/markdown/</id>
    <published>2020-11-15T06:45:32.000Z</published>
    <updated>2020-11-15T14:02:55.181Z</updated>
    
    
    
    
    <category term="文本编辑工具" scheme="http://joe-sdu.top/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://joe-sdu.top/2020/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%98%9F%E5%88%97/"/>
    <id>http://joe-sdu.top/2020/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%98%9F%E5%88%97/</id>
    <published>2020-11-15T04:28:49.000Z</published>
    <updated>2020-11-15T13:59:42.793Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p><a id="more"></a><h2 id="队列类的实现"><a href="#队列类的实现" class="headerlink" title="队列类的实现"></a>队列类的实现</h2><blockquote><p>队列的实现较为简单，我们给出具体的类，然后再讨论队列的习题。</p></blockquote><ul><li>纯虚基类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>数组实现的队列<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总是要从别的文件粘贴栈过来好烦，用stl又不太正经</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PureBaseQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayQueue</span> :</span> <span class="keyword">public</span> <span class="built_in">queue</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">arrayQueue(<span class="keyword">int</span> initialCapacity = <span class="number">20</span>);</span><br><span class="line">~arrayQueue() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> theFront == theBack; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (theBack - theFront + arrayLength) % arrayLength; &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* element;</span><br><span class="line"><span class="keyword">int</span> theFront;</span><br><span class="line"><span class="keyword">int</span> theBack;</span><br><span class="line"><span class="keyword">int</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">arrayQueue&lt;T&gt;::arrayQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">arrayLength = initialCapacity;</span><br><span class="line">theFront = theBack = <span class="number">0</span>;</span><br><span class="line">element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; arrayQueue&lt;T&gt;::front() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (theFront == theBack)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line"><span class="keyword">return</span> element[(theFront + <span class="number">1</span>) % arrayLength];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; arrayQueue&lt;T&gt;::back() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (theFront == theBack)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line"><span class="keyword">return</span> element[theBack];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayQueue&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (theFront == theBack)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">theFront = (theFront + <span class="number">1</span>) % arrayLength;</span><br><span class="line">element[theFront].~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayQueue&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((theBack + <span class="number">1</span>) % arrayLength == theFront)</span><br><span class="line">&#123;</span><br><span class="line">T* newQueue = <span class="keyword">new</span> T[<span class="number">2</span> * arrayLength];</span><br><span class="line"><span class="keyword">int</span> start = (theFront + <span class="number">1</span>) % arrayLength;</span><br><span class="line"><span class="keyword">if</span> (start &lt; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">std</span>::copy(element + start, element + start + arrayLength - <span class="number">1</span>, newQueue);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::copy(element + start, element + arrayLength, newQueue);</span><br><span class="line"><span class="built_in">std</span>::copy(element, element + theBack + <span class="number">1</span>, newQueue + arrayLength - start);</span><br><span class="line">&#125;</span><br><span class="line">theFront = <span class="number">2</span> * arrayLength - <span class="number">1</span>;</span><br><span class="line">theBack = arrayLength - <span class="number">2</span>;</span><br><span class="line">arrayLength *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">delete</span>[]element;</span><br><span class="line">element = newQueue;</span><br><span class="line">&#125;</span><br><span class="line">theBack = (theBack + <span class="number">1</span>) % arrayLength;</span><br><span class="line">element[theBack] = theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>链表实现的队列<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// created on Oct.23.2020 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PureBaseQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chainNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T element;</span><br><span class="line">chainNode&lt;T&gt;* next;</span><br><span class="line">chainNode() = <span class="keyword">default</span>;</span><br><span class="line">chainNode(<span class="keyword">const</span> T&amp; theElement) : element(theElement) &#123;&#125;</span><br><span class="line">chainNode(<span class="keyword">const</span> T&amp; theElement, chainNode&lt;T&gt;* theNext) : element(theElement), next(theNext) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedQueue</span> :</span> <span class="keyword">public</span> <span class="built_in">queue</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">linkedQueue(<span class="keyword">int</span> initialCapacity = <span class="number">20</span>);</span><br><span class="line">~linkedQueue();</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> queueSize == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> queueSize; &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">chainNode&lt;T&gt;* theFront;</span><br><span class="line">chainNode&lt;T&gt;* theBack;</span><br><span class="line"><span class="keyword">int</span> queueSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedQueue&lt;T&gt;::linkedQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">theFront = theBack = <span class="literal">nullptr</span>;</span><br><span class="line">queueSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedQueue&lt;T&gt;::~linkedQueue()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (theFront != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">chainNode&lt;T&gt;* nextNode = theFront-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> theFront;</span><br><span class="line">theFront = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; linkedQueue&lt;T&gt;::front() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line"><span class="keyword">return</span> theFront-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; linkedQueue&lt;T&gt;::back() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line"><span class="keyword">return</span> theBack-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedQueue&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">chainNode&lt;T&gt;* nextNode = theFront-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> theFront;</span><br><span class="line">theFront = nextNode;</span><br><span class="line">queueSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedQueue&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">chainNode&lt;T&gt;* newNode = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line">theFront = theBack = newNode;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">theBack-&gt;next = newNode;</span><br><span class="line">theBack = newNode;</span><br><span class="line">&#125;</span><br><span class="line">queueSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法习题答案(机械工业出版社)" scheme="http://joe-sdu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript基础知识</title>
    <link href="http://joe-sdu.top/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Javascript%E5%9F%BA%E7%A1%80/"/>
    <id>http://joe-sdu.top/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Javascript%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-13T08:47:39.000Z</published>
    <updated>2020-11-13T08:48:07.755Z</updated>
    
    
    
    
    <category term="搭建一个小型博客需要的前导知识" scheme="http://joe-sdu.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E5%8D%9A%E5%AE%A2%E9%9C%80%E8%A6%81%E7%9A%84%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS基础知识</title>
    <link href="http://joe-sdu.top/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/CSS%E5%9F%BA%E7%A1%80/"/>
    <id>http://joe-sdu.top/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/CSS%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-13T08:44:17.000Z</published>
    <updated>2020-11-13T08:44:48.754Z</updated>
    
    
    
    
    <category term="搭建一个小型博客需要的前导知识" scheme="http://joe-sdu.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E5%8D%9A%E5%AE%A2%E9%9C%80%E8%A6%81%E7%9A%84%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML基础知识</title>
    <link href="http://joe-sdu.top/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/HTML%E5%9F%BA%E7%A1%80/"/>
    <id>http://joe-sdu.top/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/HTML%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-13T06:45:32.000Z</published>
    <updated>2020-11-14T14:59:14.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML基础篇"><a href="#HTML基础篇" class="headerlink" title="HTML基础篇"></a><strong>HTML基础篇</strong></h2><blockquote><p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p></blockquote><a id="more"></a><ul><li><input disabled="" type="checkbox"> HTML的基本框架<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是小徐的html页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p1</span>&gt;</span>这里是第一段<span class="tag">&lt;/<span class="name">p1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>注意:HTML中<xxx>代表一个标记，标记通常是成对存在的。</li><li><input disabled="" type="checkbox"> 如何开始编辑HTML</li></ul><p>1.直接采用记事本，具体操作很简单:鼠标停留在桌面–&gt;右键–&gt;建立文本文件–&gt;键入代码块–&gt;修改文件后缀为.html–&gt;保存文件–&gt;再次打开该文件。</p><blockquote><p>值得注意的是，默认解释html文件的浏览器是你电脑上设置的默认浏览器，windows用户默认浏览器可在设置里修改。</p></blockquote><p>2.使用VScode、sublime Text等文本编辑器进行html文件的编写。</p><ul><li><p><input disabled="" type="checkbox">  HTML中的保留字<br> 所谓保留字，就是一组html语法规范里出现的关键字或者符号，包括&lt;和&gt;等等，浏览器在遇到这些符号时会不清楚到底是一个标签还是小于号/大于号。我们可以用实体数字来解决此问题。常见的实体数字如下:</p><table><thead><tr><th>保留字</th><th>实体名称(不推荐)</th><th>实体编号</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;it</td><td>&amp;#60</td></tr><tr><td>&gt;</td><td>&amp;gt</td><td>&amp;#62</td></tr><tr><td>空格</td><td>&amp;nbsp</td><td>&amp;#160</td></tr></tbody></table></li><li><p><input disabled="" type="checkbox">  HTML标题<br>HTML标题，也称heading，是通过h1到h6六个标签定义的，标题会被默认显示成大字、粗体。我们给出实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是第二个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox">  HTML段落<br>HTML段落，也称paragraph，是通过p标签定义的。我们给出实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips:默认情况下浏览器会在标题前后增加默认空行，会在块级元素后增加一个空行。<br>标题不可做他用，搜索引擎用标题为网页的结构和内容编制索引。<br>网页标题从h1到h6优先级递减。</p></blockquote></li><li><p><input disabled="" type="checkbox">  HTML水平线<br>HTML水平线，用来在界面中分割内容，用hr表示，我们给出实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox">  HTML注释<br>注释是给编写代码的人看的，不会影响网页结构，格式如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是注释 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox">  HTML链接<br>HTML链接，也称link，是通过a标签定义的。我们给出实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;joe-sdu.top&quot;</span>&gt;</span>顺着网线就能找到小徐!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>其中href后面跟着的是链接地址，两个标签里的话是网页显示的文字，点击这句话就能跳转。</p></li><li><p><input disabled="" type="checkbox">  HTML图像<br>HTML图像，是通过img标签定义的。我们给出实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:/Users/images/小徐的照片屋&quot;</span> <span class="attr">width</span> = <span class="string">&quot;100&quot;</span> <span class="attr">height</span> = <span class="string">&quot;200&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这个例子似乎有点特殊，原因在于，它没有成对的标签，而是在一个标签里加入了/，同时它引入了几个属性，src:也称source，代表存放图片的路径，width:希望展示图片的宽度，height:希望展示图片的高度。</p></li><li><p><input disabled="" type="checkbox">  HTML元素<br>HTML元素，指的是在开始标记和结束标记之间的内容(也就是上面所说的一对标签之内的内容)。HTML元素语法如下:</p></li><li><p>HTML元素以开始标记为起始。</p></li><li><p>HTML元素以结束标记为结束。</p></li><li><p>HTML元素内容是位于开始和结束标签之间的内容。</p></li><li><p>HTML某些元素具有空内容。</p></li><li><p>HTML空元素在开始标记中就结束。</p></li><li><p>HTML大多数元素可以拥有属性，比如上面的img。</p></li><li><p>HTML元素可以嵌套，简而言之就是一个元素中可以包含其他元素。<br>我们针对一些特殊的HTML元素进行解释:</p></li><li><p>HTML中的html元素，它定义了整个html文档。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">这里是其他元素内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML中的body元素，它定义了文档的主体。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">这里是其他元素内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML中的空元素，以换行为例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips:html中的标签最好采用小写，即使html对大小写并不敏感。</p></blockquote></li><li><p><input disabled="" type="checkbox">  HTML属性</p></li><li><p>HTML中的属性总是以键值对的形式出现，且在开始标签中规定，属性值总是要打引号，属性采用小写(尽管html不区分大小写)。我们给出一些针对性属性及其含义:</p><table><thead><tr><th>属性</th><th>定义的标签</th><th>符号</th></tr></thead><tbody><tr><td>链接</td><td>a</td><td>href</td></tr><tr><td>居中排列标题</td><td>h</td><td>align</td></tr><tr><td>背景颜色</td><td>body</td><td>bgcolor</td></tr><tr><td>表格边框</td><td>table</td><td>boder</td></tr></tbody></table></li><li><p>下面是一些适用于大多数HTML元素的属性:</p><table><thead><tr><th>属性</th><th>符号</th></tr></thead><tbody><tr><td>规定元素的内容</td><td>class</td></tr><tr><td>规定元素唯一的id</td><td>id</td></tr><tr><td>规定元素的行内样式</td><td>style</td></tr><tr><td>规定元素额外的信息</td><td>title</td></tr></tbody></table><p><a href="https://www.w3schools.com/html/">更多具体属性可点击查看</a></p></li><li><p><input disabled="" type="checkbox">  HTML样式<br>HTML样式通过style属性来设置，在以前，有些样式可以通过一些标签和属性来实现。然而在HTML的发展过程中，有些标签和属性逐渐被淘汰，我们应该尽量避免使用，它们是:</p><table><thead><tr><th>标签名</th><th>描述</th></tr></thead><tbody><tr><td>center</td><td>定义居中的内容</td></tr><tr><td>font/basefont</td><td>定义字体</td></tr><tr><td>s/strike</td><td>定义删除线文本</td></tr><tr><td>u</td><td>定义下划线文本</td></tr></tbody></table><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>align</td><td>定义文字对齐方式</td></tr><tr><td>bgcolor</td><td>定义背景颜色</td></tr><tr><td>color</td><td>定义文本颜色</td></tr></tbody></table></li><li><p>我们用对应的样式代替上面的标签和属性:</p></li></ul><p>1.用background-color样式代替bgcolor:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span> = <span class="string">&quot;background-color:green&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这是绿色的主体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span> = <span class="string">&quot;background-color:red&quot;</span>&gt;</span>这是红色的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">&quot;background-color:blue&quot;</span>&gt;</span>这是蓝色的段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML进阶篇"><a href="#HTML进阶篇" class="headerlink" title="HTML进阶篇"></a>HTML进阶篇</h2><p><strong>小徐还没来得及写哦~</strong></p><h2 id="很适合学习的时候听的歌呀"><a href="#很适合学习的时候听的歌呀" class="headerlink" title="很适合学习的时候听的歌呀!"></a>很适合学习的时候听的歌呀!</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=35847042&auto=1&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTML基础篇&quot;&gt;&lt;a href=&quot;#HTML基础篇&quot; class=&quot;headerlink&quot; title=&quot;HTML基础篇&quot;&gt;&lt;/a&gt;&lt;strong&gt;HTML基础篇&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="搭建一个小型博客需要的前导知识" scheme="http://joe-sdu.top/categories/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E5%8D%9A%E5%AE%A2%E9%9C%80%E8%A6%81%E7%9A%84%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://joe-sdu.top/2020/11/13/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://joe-sdu.top/2020/11/13/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2020-11-13T00:48:49.000Z</published>
    <updated>2020-11-16T04:08:26.788Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们终将被忘记。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我们终将被忘记。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="记录生活" scheme="http://joe-sdu.top/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%88/"/>
    <id>http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%88/</id>
    <published>2020-11-12T04:28:49.000Z</published>
    <updated>2020-11-16T13:10:15.684Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p><a id="more"></a><h2 id="栈在教材上的应用"><a href="#栈在教材上的应用" class="headerlink" title="栈在教材上的应用"></a>栈在教材上的应用</h2><blockquote><p>栈是一种十分有用的数据结构!!在后续学习中会不断出现对它的应用!!请大家务必掌握!!</p></blockquote><ul><li>栈的纯虚基类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯虚基类</span></span><br><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H_</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">stack</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>数组实现的栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组实现的栈</span></span><br><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pureBaseStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayStack</span> :</span> <span class="keyword">public</span> <span class="built_in">stack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~arrayStack() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line">arrayStack(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> stackTop == <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> stackTop + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* element;</span><br><span class="line"><span class="keyword">int</span> stackTop;</span><br><span class="line"><span class="keyword">int</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">arrayStack&lt;T&gt;::arrayStack(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;can&#x27;t creat a stack with capacity &lt;= 0!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">stackTop = <span class="number">-1</span>;</span><br><span class="line">arrayLength = initialCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; arrayStack&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackTop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> element[stackTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayStack&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackTop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;can&#x27;t pop from an empty stack!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">element[stackTop--].~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayStack&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackTop == arrayLength - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">arrayLength *= <span class="number">2</span>;</span><br><span class="line">T* temp = <span class="keyword">new</span> T[arrayLength];</span><br><span class="line"><span class="built_in">std</span>::copy(element, element + stackTop + <span class="number">1</span>, temp);</span><br><span class="line"><span class="keyword">delete</span>[]element;</span><br><span class="line">element = temp;</span><br><span class="line">&#125;</span><br><span class="line">element[++stackTop] = theElement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>链表实现的栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pureBaseStack.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T element;</span><br><span class="line">stackNode* next;</span><br><span class="line">stackNode() = <span class="keyword">default</span>;</span><br><span class="line">stackNode(<span class="keyword">const</span> T&amp; theElement) : element(theElement) &#123;&#125;</span><br><span class="line">stackNode(<span class="keyword">const</span> T&amp; theElement, stackNode&lt;T&gt;* theNext) : element(theElement), next(theNext) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedStack</span> :</span> <span class="keyword">public</span> <span class="built_in">stack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~linkedStack();</span><br><span class="line">linkedStack(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> stackSize == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>&#123; <span class="keyword">return</span> stackSize; &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stackNode&lt;T&gt;* stackTop;</span><br><span class="line"><span class="keyword">int</span> stackSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedStack&lt;T&gt;::~linkedStack()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (stackTop != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">stackNode&lt;T&gt;* nextNode = stackTop-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> stackTop;</span><br><span class="line">stackTop = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedStack&lt;T&gt;::linkedStack(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;can&#x27;t creat a stack with capacity &lt;= 0!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">stackSize = <span class="number">0</span>;</span><br><span class="line">stackTop = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; linkedStack&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stackTop-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedStack&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;can&#x27;t pop from an empty stack!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">stackNode&lt;T&gt;* nextNode = stackTop-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> stackTop;</span><br><span class="line">stackTop = nextNode;</span><br><span class="line">stackSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedStack&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">stackTop = <span class="keyword">new</span> stackNode&lt;T&gt;(theElement, stackTop);</span><br><span class="line">stackSize++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>双栈共享空间<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TWOSTACKS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOSTACKS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">twoStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~twoStack() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line">twoStack(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> stackTop1 == <span class="number">-1</span> &amp;&amp; stackTop2 == arrayLength; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> stackTop1 - stackTop2 + arrayLength + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">(<span class="keyword">int</span> stackNumber)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNumber)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNumber, <span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* element;</span><br><span class="line"><span class="keyword">int</span> stackTop1;</span><br><span class="line"><span class="keyword">int</span> stackTop2;</span><br><span class="line"><span class="keyword">int</span> arrayLength;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> stackNumber)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> twoStack&lt;T&gt;::check(<span class="keyword">int</span> stackNumber) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackNumber &lt; <span class="number">1</span> || stackNumber &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;stackNumber input error!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">twoStack&lt;T&gt;::twoStack(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">arrayLength = initialCapacity;</span><br><span class="line">stackTop1 = <span class="number">-1</span>;</span><br><span class="line">stackTop2 = arrayLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; twoStack&lt;T&gt;::top(<span class="keyword">int</span> stackNumber) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">check(stackNumber);</span><br><span class="line"><span class="keyword">switch</span> (stackNumber)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (stackTop1 == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;stack1 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> element[stackTop1];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (stackTop2 == arrayLength)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;stack2 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> element[stackTop2];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> twoStack&lt;T&gt;::pop(<span class="keyword">int</span> stackNumber)</span><br><span class="line">&#123;</span><br><span class="line">check(stackNumber);</span><br><span class="line"><span class="keyword">switch</span> (stackNumber)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (stackTop1 == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;stack1 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">element[stackTop1--].~T();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (stackTop2 == arrayLength)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">s &lt;&lt; <span class="string">&quot;stack2 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">throw</span> s.str();</span><br><span class="line">&#125;</span><br><span class="line">element[stackTop2++].~T();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> twoStack&lt;T&gt;::push(<span class="keyword">int</span> stackNumber, <span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">check(stackNumber);</span><br><span class="line"><span class="keyword">if</span> (stackTop1 + <span class="number">1</span> == stackTop2)</span><br><span class="line">&#123;</span><br><span class="line">T* temp = <span class="keyword">new</span> T[<span class="number">2</span> * arrayLength];</span><br><span class="line"><span class="built_in">std</span>::copy(element, element + stackTop1 + <span class="number">1</span>, temp);</span><br><span class="line"><span class="built_in">std</span>::copy(element + stackTop2, element + arrayLength, temp + arrayLength + stackTop2);</span><br><span class="line"><span class="keyword">delete</span>[]element;</span><br><span class="line">element = temp;</span><br><span class="line">stackTop2 = arrayLength + stackTop2;</span><br><span class="line">arrayLength *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (stackNumber)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">element[++stackTop1] = theElement;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">element[--stackTop2] = theElement;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>括号匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// complexity of time:O(s.size())</span></span><br><span class="line"><span class="comment">// extra complexity of space:O(s.size())</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchWithStack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arrayStack&lt;<span class="keyword">char</span>&gt; matchStack;</span><br><span class="line"><span class="keyword">char</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">matchStack.push(s[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = matchStack.top();</span><br><span class="line"><span class="keyword">if</span> (temp == s[i])</span><br><span class="line">matchStack.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!matchStack.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>列车重排<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列车重排</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">arrayStack&lt;<span class="keyword">int</span>&gt;* rails;</span><br><span class="line"><span class="keyword">int</span> numberOfCars;</span><br><span class="line"><span class="keyword">int</span> numberOfTrails;</span><br><span class="line"><span class="keyword">int</span> smallestCar;</span><br><span class="line"><span class="keyword">int</span> itsTrail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputCarFromTrail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rails[itsTrail].pop();</span><br><span class="line">smallestCar = numberOfCars + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfTrails; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!rails[i].empty() &amp;&amp; rails[i].top() &lt; smallestCar)</span><br><span class="line">&#123;</span><br><span class="line">smallestCar = rails[i].top();</span><br><span class="line">itsTrail = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inputCarToTrail</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bestTrail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bestTop = numberOfCars + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfTrails; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!rails[i].empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d = rails[i].top();</span><br><span class="line"><span class="keyword">if</span> (n &lt; d &amp;&amp; d &lt; bestTop)</span><br><span class="line">&#123;</span><br><span class="line">bestTop = d;</span><br><span class="line">bestTrail = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">bestTrail = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bestTrail == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">rails[bestTrail].push(n);</span><br><span class="line"><span class="keyword">if</span> (n &lt; smallestCar)</span><br><span class="line">&#123;</span><br><span class="line">smallestCar = n;</span><br><span class="line">itsTrail = bestTrail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">railRoad</span><span class="params">(<span class="keyword">int</span> input[], <span class="keyword">int</span> theNumberOfCars, <span class="keyword">int</span> theNumberOfTrails)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">numberOfCars = theNumberOfCars;</span><br><span class="line">numberOfTrails = theNumberOfTrails;</span><br><span class="line">rails = <span class="keyword">new</span> arrayStack&lt;<span class="keyword">int</span>&gt;[theNumberOfTrails + <span class="number">1</span>];</span><br><span class="line">smallestCar = numberOfCars + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nextCarToOutput = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfCars; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] == nextCarToOutput)</span><br><span class="line">&#123;</span><br><span class="line">nextCarToOutput++;</span><br><span class="line"><span class="keyword">while</span> (smallestCar == nextCarToOutput)</span><br><span class="line">&#123;</span><br><span class="line">outputCarFromTrail();</span><br><span class="line">nextCarToOutput++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (!inputCarToTrail(input[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>离线等价类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 离线等价类</span></span><br><span class="line"><span class="comment">// offline equiralence classes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">offlineEquiralenceClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, r;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;can&#x27;t calculate set with elements &lt; 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;can&#x27;t calculate set with relations &lt; 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">arrayStack&lt;<span class="keyword">int</span>&gt;* <span class="built_in">list</span> = <span class="keyword">new</span> arrayStack&lt;<span class="keyword">int</span>&gt;[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">list</span>[a].push(b);</span><br><span class="line"><span class="built_in">list</span>[b].push(a);</span><br><span class="line">&#125;</span><br><span class="line">arrayStack&lt;<span class="keyword">int</span>&gt; unprocessedList;</span><br><span class="line"><span class="keyword">bool</span> *out = <span class="keyword">new</span> <span class="keyword">bool</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">out[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> tol = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!out[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class &quot;</span> &lt;&lt; tol &lt;&lt; <span class="string">&quot; is:&quot;</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">out[i] = <span class="literal">true</span>;</span><br><span class="line">unprocessedList.push(i);</span><br><span class="line"><span class="keyword">while</span> (!unprocessedList.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = unprocessedList.top();</span><br><span class="line">unprocessedList.pop();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">list</span>[j].empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = <span class="built_in">list</span>[j].top();</span><br><span class="line"><span class="built_in">list</span>[j].pop();</span><br><span class="line"><span class="keyword">if</span> (!out[q])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">out[q] = <span class="literal">true</span>;</span><br><span class="line">unprocessedList.push(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">tol++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>汉诺塔<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">arrayStack&lt;<span class="keyword">int</span>&gt; Hanoi[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveAndShow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">moveAndShow(n - <span class="number">1</span>, x, z, y);</span><br><span class="line"><span class="keyword">int</span> d = Hanoi[x].top();</span><br><span class="line">Hanoi[x].pop();</span><br><span class="line">Hanoi[y].push(d);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;从&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;移动[&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;到&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">moveAndShow(n - <span class="number">1</span>, z, y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HanoiTower</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">Hanoi[<span class="number">1</span>].push(i);</span><br><span class="line">moveAndShow(n, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迷宫老鼠<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迷宫老鼠</span></span><br><span class="line"><span class="comment">// find path in a maze</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> maze[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入迷宫尺寸:&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++)</span><br><span class="line">&#123;</span><br><span class="line">maze[<span class="number">0</span>][i] = maze[size + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">maze[i][<span class="number">0</span>] = maze[i][size + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">arrayStack&lt;position&gt;* path = <span class="keyword">new</span> arrayStack&lt;position&gt;;</span><br><span class="line"><span class="keyword">int</span> barrRow, barrCol;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入障碍数量:&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; barrRow &gt;&gt; barrCol;</span><br><span class="line"><span class="keyword">while</span>(barrRow &lt; <span class="number">1</span> || barrCol &lt; <span class="number">1</span> || barrRow &gt; size || barrCol &gt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入的障碍物有误，请输入正确的障碍物坐标:&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; barrRow &gt;&gt; barrCol;</span><br><span class="line">&#125;</span><br><span class="line">maze[barrRow][barrCol] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">position end;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入终点位置:&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; end.row &gt;&gt; end.col;</span><br><span class="line"><span class="keyword">while</span> (end.row &lt; <span class="number">0</span> || end.col &lt; <span class="number">0</span> || end.row &gt; size + <span class="number">1</span> || end.col &gt; size + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;终点位置不符合规范，请重新输入:&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; end.row &gt;&gt; end.col;</span><br><span class="line">&#125;</span><br><span class="line">position offset[<span class="number">4</span>];</span><br><span class="line">offset[<span class="number">0</span>].row = <span class="number">0</span>; offset[<span class="number">0</span>].col = <span class="number">1</span>;</span><br><span class="line">offset[<span class="number">1</span>].row = <span class="number">1</span>; offset[<span class="number">1</span>].col = <span class="number">0</span>;</span><br><span class="line">offset[<span class="number">2</span>].row = <span class="number">0</span>; offset[<span class="number">2</span>].col = <span class="number">-1</span>;</span><br><span class="line">offset[<span class="number">3</span>].row = <span class="number">-1</span>; offset[<span class="number">3</span>].col = <span class="number">0</span>;</span><br><span class="line">position here;</span><br><span class="line">here.row = <span class="number">1</span>; here.col = <span class="number">1</span>;</span><br><span class="line">maze[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> option = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lastOption = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (here.row != end.row || here.col != end.col)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="keyword">while</span> (option &lt;= lastOption)</span><br><span class="line">&#123;</span><br><span class="line">r = here.row + offset[option].row;</span><br><span class="line">c = here.col + offset[option].col;</span><br><span class="line"><span class="keyword">if</span> (maze[r][c] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">option++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (option &lt;= lastOption)</span><br><span class="line">&#123;</span><br><span class="line">path-&gt;push(here);</span><br><span class="line">here.row = r;</span><br><span class="line">here.col = c;</span><br><span class="line">maze[r][c] = <span class="number">1</span>;</span><br><span class="line">option = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (path-&gt;empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">position next = path-&gt;top();</span><br><span class="line">path-&gt;pop();</span><br><span class="line"><span class="keyword">if</span> (next.row == here.row)</span><br><span class="line">option = <span class="number">2</span> + next.col - here.col;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">option = <span class="number">3</span> + (next.row - here.row) % <span class="number">4</span>;</span><br><span class="line">here = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!path-&gt;empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; path-&gt;top().row &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; path-&gt;top().col &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">path-&gt;pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>开关盒布线<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关盒布线</span></span><br><span class="line"><span class="comment">// check net and judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linkedStack.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBox</span><span class="params">(<span class="keyword">int</span> net[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">linkedStack&lt;<span class="keyword">int</span>&gt;* s = <span class="keyword">new</span> linkedStack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!s-&gt;empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (net[i] == net[s-&gt;top()])</span><br><span class="line">s-&gt;pop();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s-&gt;push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s-&gt;push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!s-&gt;empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;box is not routable!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;box is routable!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的习题"><a href="#栈的习题" class="headerlink" title="栈的习题"></a>栈的习题</h2>小徐太懒了还没开始写~</li></ul><h2 id="前中后缀表达式-学习让计算机处理算术表达式"><a href="#前中后缀表达式-学习让计算机处理算术表达式" class="headerlink" title="前中后缀表达式: 学习让计算机处理算术表达式"></a>前中后缀表达式: 学习让计算机处理算术表达式</h2><ul><li><p><input disabled="" type="checkbox">  了解前中后缀表达式</p></li><li><p><input disabled="" type="checkbox">  中缀表达式<br>中缀表达式是最贴近我们人的阅读习惯的一类表达式，它和我们平常生活中接触到的数学算式没有区别，它的出现完全是方便人类进行数学演算，然而这种表达式对计算机而言是生涩难懂的。</p></li><li><p>中缀表达式形如: $3\times 2+(4-2)\times 7 -8\div (6+3)$</p></li><li><p><input disabled="" type="checkbox">  前缀表达式<br>顾名思义，前缀表达式是运算符在它的(注意这个”它的”的含义)操作数之前的表达式，计算机很容易就能在线性时间内完成对前缀表达式的计算。</p></li><li><p>前缀表达式形如: $-+1\times +2\ 3\ 4\ 5$</p></li><li><p>中缀表达式转前缀表达式的规则:</p></li></ul><p>1.维护两个栈，一个栈叫做s1，另一个栈叫做s2，s2用来保存中间结果。<br>2.从右至左扫描中缀表达式:</p><ul><li><p>若遇到数字，直接压入栈s1.</p></li><li><p>若遇到运算符，则分以下情况:<br>  1.s2为空或者栈顶运算符为’)’，则直接将其压入s2。</p><p>  2.s2中栈顶运算符优先级不高于($\leq$)此运算符，也将该运算符压入s2。 </p><p>  3.s2中栈顶元素优先级高于该运算符，则持续将s2栈顶的元素弹入s1，直到某一刻s2栈顶的元素满足如上1，2两个条件之一，则将该运算符压入s2(在此之前这个运算符一直在等待着被插入)。</p></li></ul><p>3.遇到括号时:</p><ul><li>如果是’)’，则直接压入s2。</li><li>如果是’(‘，则持续将s2的栈顶元素弹入s1，直到遇到’)’，然后将s2顶部的’)’弹出。</li></ul><p>4.扫描结束时，把s2中剩余运算符全部弹入s1。<br>5.把s1中元素全部弹出。</p><ul><li>计算前缀表达式</li></ul><p>1.同样维护一个栈，名叫s1。</p><p>2.从右至左扫描前缀表达式，遇到数字，则进栈，遇到运算符，则取出栈顶的两个元素，按照先后顺序称为$x_1$和$x_2$，计算$x_1$ $(+\ -\ \times \ \div)$ $x_2$，把结果入栈。</p><p>3.扫描结束时，s1中剩余元素即是结果。</p><blockquote><p>Tips:为什么在比较操作符优先级时，栈顶运算的优先级不高于正在操作的运算符时才压入栈呢?想象一下，当有两个同样优先级的运算符出现在中缀表达式中时，举个例子，$+和-$，假设$+$在左，$-$<br>在右，由于我们是从右向左扫描，$-$必然会在$+$之前进入s2，此时，如若在碰到$+$后，直接将$-$弹入s1，那么在最终得到的前缀表达式中，$-$必然在$+$之后出现，然而计算时扫描是从右往左，这意味着<br>最终计算时$-$先被拿来计算了，这显然不正确。</p></blockquote><ul><li><p>举例(自行模拟):</p></li><li><p>中缀表达式: $$1+((2+3)\times 4)-5$$</p></li><li><p>其前缀表达式为$$-+1\times+2\ 3\ 4\ 5$$</p></li><li><p>计算的过程:<br>$$将5，4，3，2均入栈$$<br>$$取2和3，执行2+3，把5入栈$$<br>$$取5和4，执行5\times 4，把20入栈$$<br>$$……$$<br>$$得到结果为16.$$</p></li><li><p><input disabled="" type="checkbox">  后缀表达式<br>后缀表达式和前缀表达式十分类似，但在细节处有所不同。后缀表达式是运算符都在它的操作数之后的表达式。</p></li><li><p>后缀表达式形如: $1\ 2\ 3 + 4\times+5-$</p></li><li><p>中缀表达式转后缀表达式的规则:</p></li></ul><p>1.维护两个栈，一个栈叫做s1，另一个栈叫做s2，s2用来保存中间结果。<br>2.从左至右扫描中缀表达式:</p><ul><li><p>若遇到数字，直接压入栈s1.</p></li><li><p>若遇到运算符，则分以下情况:<br>  1.s2为空或者栈顶运算符为’(‘，则直接将其压入s2。</p><p>  2.s2中栈顶运算符优先级低于(细节!!)此运算符，也将该运算符压入s2。 </p><p>  3.s2中栈顶元素优先级不低于($\geq$)该运算符，则持续将s2栈顶的元素弹入s1，直到某一刻s2栈顶的元素满足如上1，2两个条件之一，则将该运算符压入s2(在此之前这个运算符一直在等待着被插入)。</p></li></ul><p>3.遇到括号时:</p><ul><li>如果是’(‘，则直接压入s2。</li><li>如果是’)’，则持续将s2的栈顶元素弹入s1，直到遇到’(‘，然后将s2顶部的’(‘弹出。</li></ul><p>4.扫描结束时，把s2中剩余运算符全部弹入s1。<br>5.把s1中元素全部弹出。</p><ul><li>计算后缀表达式</li></ul><p>1.同样维护一个栈，名叫s1。</p><p>2.从左至右扫描后缀表达式，遇到数字，则进栈，遇到运算符，则取出栈顶的两个元素，按照先后顺序称为$x_1$和$x_2$，计算$x_2$ $(+\ -\ \times \ \div)$ $x_1$(细节!!)，把结果入栈。</p><p>3.扫描结束时，s1中剩余元素即是结果。</p><ul><li><p>例子不表</p></li><li><p><input disabled="" type="checkbox">  给定中缀表达式求运算结果的C++实现: 仅给出中缀转前缀实现，该实现仅能计算10以内的整数的中缀表达式，扩展可以自行实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> expr;</span><br><span class="line">arrayStack&lt;<span class="keyword">char</span>&gt; s1, s2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; expr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = expr.length()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// Scan from right to left</span></span><br><span class="line"><span class="keyword">char</span> e = expr.at(i);</span><br><span class="line"><span class="keyword">if</span> (e &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; e &lt;= <span class="string">&#x27;9&#x27;</span>) s1.push(e);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="string">&#x27;)&#x27;</span>) s2.push(e);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line"><span class="keyword">char</span> t = s2.top();</span><br><span class="line">s2.pop();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">s1.push(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s2.empty()) &#123; s2.push(e); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">char</span> t = s2.top();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">&#x27;)&#x27;</span>) s2.push(e);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="string">&#x27;*&#x27;</span> || e == <span class="string">&#x27;/&#x27;</span>) s2.push(e);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">t = s2.top();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">&#x27;+&#x27;</span> || t == <span class="string">&#x27;-&#x27;</span> || t == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">s2.push(e);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">s1.push(t);</span><br><span class="line">s2.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s2.empty()) s2.push(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s2.empty()) &#123; <span class="comment">// Clear remaining</span></span><br><span class="line"><span class="keyword">char</span> t = s2.top();</span><br><span class="line">s2.pop();</span><br><span class="line">s1.push(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s1.empty()) &#123; <span class="comment">// Output</span></span><br><span class="line"><span class="keyword">char</span> t = s1.top();</span><br><span class="line">s1.pop();</span><br><span class="line">s2.push(t);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// To use double, we open another Stack</span></span><br><span class="line">arrayStack&lt;<span class="keyword">double</span>&gt; s3;</span><br><span class="line"><span class="keyword">while</span> (!s2.empty()) &#123; <span class="comment">// Scan from right to left</span></span><br><span class="line"><span class="keyword">char</span> e = s2.top();</span><br><span class="line">s2.pop();</span><br><span class="line"><span class="keyword">if</span> (e &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; e &lt;= <span class="string">&#x27;9&#x27;</span>) s3.push(<span class="keyword">double</span>(e-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> left = s3.top();</span><br><span class="line">s3.pop();</span><br><span class="line"><span class="keyword">double</span> right = s3.top();</span><br><span class="line">s3.pop();</span><br><span class="line"><span class="keyword">switch</span> (e) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: &#123;result = left + right; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: &#123;result = left - right; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: &#123;result = left * right; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: &#123;result = left / right; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">s3.push(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; s3.top();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时间复杂度:$$O(n)，表达式中每个元素最多进栈和出栈常数次。$$</p></li></ul><p><strong>实际上，前缀表达式称为波兰式，后缀表达式称为逆波兰式。</strong></p><ul><li><input disabled="" type="checkbox"> 人工求前后缀表达式的简易方法:</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法习题答案(机械工业出版社)" scheme="http://joe-sdu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/"/>
    <id>http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/</id>
    <published>2020-11-12T04:28:49.000Z</published>
    <updated>2020-11-18T09:53:39.155Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p><a id="more"></a><h2 id="二叉树和其他树"><a href="#二叉树和其他树" class="headerlink" title="二叉树和其他树"></a>二叉树和其他树</h2><blockquote><p>Tips:先把书上的代码弄出来吧~</p></blockquote><ul><li><p>层序遍历用到了队列</p></li><li><p>队列实现自行参考之前的队列章节</p></li><li><p><input disabled="" type="checkbox">  类的实现: 让树生根发芽<br>二叉树的ADT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BINARYTREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARYTREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Pure virtual base class: all other kinds of tree derived from it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~binaryTree() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">void</span> (*)(T*))</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">void</span> (*)(T*))</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">void</span> (*)(T*))</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Explanation: </span></span><br><span class="line"><span class="comment">some of you may ask this: why our travelsal functions can&#x27;t be &#x27;const&#x27;.</span></span><br><span class="line"><span class="comment">We should know the fact: travelsal doesn&#x27;t mean see the element,we can</span></span><br><span class="line"><span class="comment">use those functions to change the tree, even delete it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>链表二叉树的链表节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BINARYTREENODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARYTREENODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">When decided to make a structure with linked list,the first step is to make its node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T element;</span><br><span class="line">binaryTreeNode&lt;T&gt;* left, * right;</span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">binaryTreeNode() : element(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">binaryTreeNode(<span class="keyword">const</span> T&amp; theElement) : element(theElement), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">binaryTreeNode(<span class="keyword">const</span> T&amp; theElement, binaryTreeNode&lt;T&gt;* theLeft, binaryTreeNode&lt;T&gt;* theRight)</span><br><span class="line">: element(theElement), left(theLeft), right(theRight) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>链表二叉树的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKED_BINARY_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKED_BINARY_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binaryTreeNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binaryTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s a great habit--not using &#x27;namespace std&#x27; in a header file.</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.Details: binaryTree&lt;binaryTreeNode&lt;E&gt;&gt; should be written as:</span></span><br><span class="line"><span class="comment">binaryTree&lt;binaryTreeNode&lt;E&gt; &gt; (add a space at the end)</span></span><br><span class="line"><span class="comment">if the version of your C++ is not C++11, for example: C++98.</span></span><br><span class="line"><span class="comment">2.Static pointer &#x27;dynamicVisit&#x27; can be changed! That is how we</span></span><br><span class="line"><span class="comment">change our method when use traversal functions.</span></span><br><span class="line"><span class="comment">3.We use static functions to operate our traversal functions,</span></span><br><span class="line"><span class="comment">this seems a little cumbersome. But in fact, we can never let our</span></span><br><span class="line"><span class="comment">users(other programmers) to pass a pointer to our function! They even</span></span><br><span class="line"><span class="comment">don&#x27;t know where is our root. This is called packaging.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="comment">// E standardize for element</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedBinaryTree</span> :</span> <span class="keyword">public</span> binaryTree&lt;binaryTreeNode&lt;E&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~linkedBinaryTree() &#123; postOrder(dispose); root = <span class="literal">nullptr</span>; treeSize = <span class="number">0</span>; &#125;</span><br><span class="line">linkedBinaryTree() &#123; root = <span class="literal">nullptr</span>; treeSize = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> treeSize == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> treeSize; &#125;</span><br><span class="line"><span class="comment">// Inline type, overloded</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span> </span>&#123; dynamicVisit = visit; preOrder(root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span> </span>&#123; dynamicVisit = visit; inOrder(root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span> </span>&#123; dynamicVisit = visit; postOrder(root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">binaryTreeNode&lt;E&gt;* root;</span><br><span class="line"><span class="keyword">int</span> treeSize;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*dynamicVisit)</span> <span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>; <span class="comment">// default nullptr, no target.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span> </span>&#123; <span class="keyword">delete</span> subTree; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declaration of static member</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> (*linkedBinaryTree&lt;E&gt;::dynamicVisit) (binaryTreeNode&lt;E&gt;* subTree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Below are traversal functions, pay attention to their overloded type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pre-Order traversal: recursion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::preOrder(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">linkedBinaryTree&lt;E&gt;::dynamicVisit(subTree);</span><br><span class="line">preOrder(subTree-&gt;left);</span><br><span class="line">preOrder(subTree-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In-Order traversal: recursion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::inOrder(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">preOrder(subTree-&gt;left);</span><br><span class="line">linkedBinaryTree&lt;E&gt;::dynamicVisit(subTree);</span><br><span class="line">preOrder(subTree-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post-Order traversal: recursion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::postOrder(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">postOrder(subTree-&gt;left);</span><br><span class="line">postOrder(subTree-&gt;right);</span><br><span class="line">linkedBinaryTree&lt;E&gt;::dynamicVisit(subTree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::levelOrder(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">linkedBinaryTree&lt;E&gt;::dynamicVisit = visit;</span><br><span class="line">binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">arrayQueue&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line"><span class="keyword">while</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">linkedBinaryTree&lt;E&gt;::dynamicVisit(currNode);</span><br><span class="line"><span class="keyword">if</span> (currNode-&gt;left != <span class="literal">nullptr</span>) treeBucket.push(currNode-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (currNode-&gt;right != <span class="literal">nullptr</span>) treeBucket.push(currNode-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (!treeBucket.empty()) &#123;</span><br><span class="line">currNode = treeBucket.front();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> currNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实际上，到这一步之后，我们的二叉树类还完全没法用起来，原因在于，我们没法构建一棵树，而且在遍历的时候我们还未规定方法。<br>但是如上的框架已经可以称作一个比较完整的类了，后续的操作都在它上面展开。</p></li><li><p>关键一步: 造树</p><blockquote><p>造树的方法有很多很多，可以采用不断插入节点的方式，也可以采用合并树的方式，这里我们采用后者。前者在B树实现时我们再详细说。</p></blockquote></li><li><p>公有声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> theElement,linkedBinaryTree&lt;E&gt;&amp; leftTree, linkedBinaryTree&lt;E&gt;&amp; rightTree)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::makeTree(<span class="keyword">int</span> theElement, linkedBinaryTree&lt;E&gt;&amp; leftTree, linkedBinaryTree&lt;E&gt;&amp; rightTree)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="keyword">new</span> binaryTreeNode&lt;E&gt; * (theElement, leftTree.root, rightTree.root);</span><br><span class="line">leftTree.root = rightTree.root = <span class="literal">nullptr</span>;</span><br><span class="line">treeSize = leftTree.treeSize + rightTree.treeSize + <span class="number">1</span>;</span><br><span class="line">leftTree.treeSize = rightTree.treeSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历操作: 遍历通过dynamicVisit进行灵活转换，后续大部分操作都得借助它，举个例子:如果遍历时只是简单输出。那么我们可以给公有遍历函数传如下函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(binaryTreeNode&lt;T&gt;* subTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; subTree-&gt;element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这一步后，理论上如果你和我的编译环境差距不大，都是可以种出一棵树的。接下来的工作都是美化树了，我们会给出实际例子。</p></blockquote></li></ul><h2 id="习题答案，P280、281"><a href="#习题答案，P280、281" class="headerlink" title="习题答案，P280、281"></a>习题答案，P280、281</h2><ul><li><p><input disabled="" type="checkbox">  Page281，T27，计算高度</p></li><li><p>私有声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>公有接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> height(root); &#125;</span><br></pre></td></tr></table></figure></li><li><p>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">int</span> linkedBinaryTree&lt;E&gt;::height(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h1 = height(subTree-&gt;left);</span><br><span class="line"><span class="keyword">int</span> h2 = height(subTree-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (h1 &lt;= h2) <span class="keyword">return</span> ++h2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ++h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时间复杂度<br>$$T(h) = 2\times T(h-1)$$<br>$$= 4\times T(h-1)$$<br>$$= ……$$<br>$$= 2^k\times T(0)$$<br>$$= 2^k$$<br>$$k = \log_2 n, 所以T(h) = O(n).$$</p></li><li><p>空间复杂度<br>$$ 递归深度H = \log_2 n $$<br>$$ 故有S(n) = O(\log_2 n) = O(h) $$</p></li><li><p><input disabled="" type="checkbox">  Page281，T28，求节点个数</p><blockquote><p>实际上我们上面的size函数已经能实现该功能了，但是写写也无妨奥，方法也很简单。</p></blockquote></li><li><p>声明1:全局的cnt计数器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt;</span><br></pre></td></tr></table></figure></li><li><p>定义2:递增函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ascend</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span> </span>&#123; cnt++; &#125;</span><br></pre></td></tr></table></figure></li><li><p>定义:公有方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNode</span><span class="params">()</span> </span>&#123; cnt = <span class="number">0</span>; preOrder(ascend); <span class="keyword">return</span> cnt; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:如果直接把cnt定义成静态私有成员会报错，如果把ascend定义成非static函数会报错。</p></blockquote></li><li><p>时间复杂度:<br>$$ O(n) $$</p></li><li><p><input disabled="" type="checkbox">  Page281，T29，判断哪一层具有最多的节点</p></li><li><p>使用层次遍历，但是不能直接调用已有方法，而是重写一遍。</p></li><li><p>把如下声明加入公有方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLevel</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extensive Level-Order travelsal</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">int</span> linkedBinaryTree&lt;E&gt;::findMaxLevel() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">arrayQueue&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">treeBucket.push(currNode);</span><br><span class="line"><span class="keyword">int</span> maxNode = <span class="number">0</span>, maxLevel = <span class="number">0</span>, level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!treeBucket.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> capacity = treeBucket.size();</span><br><span class="line"><span class="keyword">if</span> (capacity &gt; maxNode) &#123;</span><br><span class="line">maxLevel = level; </span><br><span class="line">maxNode = capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= capacity; i++) &#123; <span class="comment">// impossible to make an exception,think twice </span></span><br><span class="line">binaryTreeNode&lt;E&gt;* tempNode = treeBucket.front();</span><br><span class="line">treeBucket.pop();</span><br><span class="line"><span class="keyword">if</span> (tempNode-&gt;left != <span class="literal">nullptr</span>) treeBucket.push(tempNode-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (tempNode-&gt;right != <span class="literal">nullptr</span>) treeBucket.push(tempNode-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 上述方法是自洽的，循环中不会出现队列抛出异常。</p></blockquote></li><li><p>时间复杂度:<br>$$ O(n)，每个节点只会入队一次. $$</p></li><li><p><input disabled="" type="checkbox">  Page281，T30-32:三题思路一致，故不分开写。栈的实现参考之前的文章。</p><blockquote><p>Tips:别忘了在头文件中包含stack!</p></blockquote></li><li><p>T30:中序遍历:不用递归就用栈，能用递归往往就能用栈实现，此题关键在于何时拐弯(如果遍历是在树中散步的话)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::inOrderWithoutRecursion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line"><span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">treeBucket.push(currNode);</span><br><span class="line">currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!treeBucket.empty()) &#123;</span><br><span class="line">currNode = treeBucket.top();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">visit(currNode);</span><br><span class="line">currNode = currNode-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>T31:前序遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::preOrderWithoutRecursion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line"><span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">visit(currNode);</span><br><span class="line">treeBucket.push(currNode);</span><br><span class="line">currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!treeBucket.empty())&#123;</span><br><span class="line">currNode = treeBucket.top();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">currNode = currNode-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>T32:后序遍历:体会其中的不同点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::postOrderWithoutRecursion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">binaryTreeNode&lt;E&gt;* currNode = root, * lastNode = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">treeBucket.push(currNode);</span><br><span class="line">currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!treeBucket.empty()) &#123;</span><br><span class="line">currNode = treeBucket.top();</span><br><span class="line"><span class="keyword">if</span> (currNode-&gt;right == <span class="literal">nullptr</span> || currNode-&gt;right == lastNode) &#123;</span><br><span class="line">treeBucket.pop();</span><br><span class="line">visit(currNode);</span><br><span class="line">lastNode = currNode;</span><br><span class="line">currNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> currNode = currNode-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要的栈空间大小等于沿着树枝散步时的最大路径长度，为O(h)。</p></li><li><p>其实上面的写法都有等价写法，这里给出前序遍历的等价写法，其他的类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::equivalentNotion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line"><span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">visit(currNode);</span><br><span class="line">treeBucket.push(currNode);</span><br><span class="line">currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">&#125;</span><br><span class="line">currNode = treeBucket.top();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">currNode = currNode-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上写法是自洽的，不会抛出异常。<br>记得在类的公有方法里加上四个声明:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderWithoutRecursion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equivalentNotion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderWithoutRecursion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderWithoutRecursion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox">  Page281、T33，34，35，三题思路一致，一起写。与此同时解决了T15-19(自己调用下就行了。爽欸都不用单独画图然后md了)，也不再单独说了。</p></li><li><p>T33:已知前序和中序求后序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::initWithPreOrderAndInOrder(E* pre, E* in, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">treeSize = theSize;</span><br><span class="line">root = initWithPreOrderAndInOrder(pre, <span class="number">0</span>, theSize - <span class="number">1</span>, in, <span class="number">0</span>, theSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">binaryTreeNode&lt;E&gt;* linkedBinaryTree&lt;E&gt;::initWithPostOrderAndInOrder(E* post, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, E* in, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pStart &gt; pEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// The end of recursion</span></span><br><span class="line">binaryTreeNode&lt;E&gt;* newNode = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(post[pEnd]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] == post[pEnd]) &#123;</span><br><span class="line">newNode-&gt;left = initWithPostOrderAndInOrder(post, pStart, pStart + i - inStart - <span class="number">1</span>, in, inStart, i - <span class="number">1</span>);</span><br><span class="line">newNode-&gt;right = initWithPostOrderAndInOrder(post, pStart + i - inStart, pEnd - <span class="number">1</span>, in, i + <span class="number">1</span>, inEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>T34:已知后序和中序求前序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">binaryTreeNode&lt;E&gt;* linkedBinaryTree&lt;E&gt;::initWithPostOrderAndInOrder(E* post, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, E* in, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pStart &gt; pEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// The end of recursion</span></span><br><span class="line">binaryTreeNode&lt;E&gt;* newNode = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(post[pEnd]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] == post[pEnd]) &#123;</span><br><span class="line">newNode-&gt;left = initWithPostOrderAndInOrder(post, pStart, pStart + i - inStart - <span class="number">1</span>, in, inStart, i - <span class="number">1</span>);</span><br><span class="line">newNode-&gt;right = initWithPostOrderAndInOrder(post, pStart + i - inStart, pEnd - <span class="number">1</span>, in, i + <span class="number">1</span>, inEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::initWithPostOrderAndInOrder(E* post, E* in, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">treeSize = theSize;</span><br><span class="line">root = initWithPostOrderAndInOrder(post, <span class="number">0</span>, theSize - <span class="number">1</span>, in, <span class="number">0</span>, theSize - <span class="number">1</span>);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 同样要记得加声明啊喂!</p></blockquote></li><li><p>T35:已知后序和前序可以求中序，当且仅当以每个节点度为0或者2。(突如其来的机工腔)</p><blockquote><p>当存在度为1的节点时不一定能唯一确定一棵树，我们可以从仅含两个节点的树设想,以下结论恒成立:一个仅含2个节点的树，左偏的前序遍历、后序遍历和右偏相同。可以以第19题作为例子自己体会。</p></blockquote></li><li><p>时间复杂度</p></li><li><p>对于已知前序和中序时，最坏情况下，二叉树的各个节点均只有左子树，此时有:<br>$$ T(n) = T(n-1) + c_1\times n $$<br>$$ = T(n-1) + c_1\times n + c_2\times (n-1) $$<br>$$ = …… $$<br>$$ = T(0) + \dfrac {n\times (n+1)}{2} $$<br>$$ = O(n^2). $$</p></li><li><p>平均情况下，二叉树为满二叉树，此时:<br>$$ T(n) = 2\times T(\dfrac {n}{2}) + \dfrac {c\times n}{2} $$<br>由<strong>master’s theory</strong>知:<br>$$ T(n) = \varTheta (n\times \log n). $$</p><blockquote><p>Tips:master’s theory，又称主定理，具体可参考博文:主定理的应用。</p></blockquote></li><li><p>T36: 输入后缀表达式，构造二叉树表示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a tree by reverse poland notion, pass an array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::makeTreeByReversePolandNotion(E* rPoland, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">treeSize = theSize;</span><br><span class="line">arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket; <span class="comment">// preserve subtrees</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theSize; i++) &#123;</span><br><span class="line">binaryTreeNode&lt;E&gt;* tempTree = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(rPoland[i]); <span class="comment">// default: left-null,right-null</span></span><br><span class="line"><span class="keyword">if</span> (rPoland[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; rPoland[i] &lt;= <span class="string">&#x27;9&#x27;</span>) treeBucket.push(tempTree);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (treeBucket.size() == <span class="number">1</span>) &#123;</span><br><span class="line">tempTree-&gt;right = treeBucket.top();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">treeBucket.push(tempTree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tempTree-&gt;right = treeBucket.top();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">tempTree-&gt;left = treeBucket.top();</span><br><span class="line">treeBucket.pop();</span><br><span class="line">treeBucket.push(tempTree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root = treeBucket.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如上实现是存在问题的，请你根据自己的理解进行修改(问题并不在程序逻辑，逻辑本身完全正确)。</p></li><li><p>T37: 用前缀表达式构造二叉树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>T38: 后缀表达式转完全括号化的中缀表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>实际上后缀表达式就是对表达式树进行后序遍历的结果，前缀表达式就是前序遍历的结果，中序同理。</p><blockquote><p>Tips:对前中后缀表达式不熟悉的话可以去栈章节找到关于前中后缀表达式的解释和实现。</p></blockquote></li><li><p>T40、T41参考栈章节，此处不再表述。</p></li><li><p>T42: 由中缀表达式得到二叉树形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>T43:计算后缀表达式的值，参考栈(稍作修改)，不再表述。</p></li></ul><h2 id="习题答案，P284、285"><a href="#习题答案，P284、285" class="headerlink" title="习题答案，P284、285"></a>习题答案，P284、285</h2><ul><li><input disabled="" type="checkbox"> Page284,T44:复制构造函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">linkedBinaryTree&lt;E&gt;::linkedBinaryTree(<span class="keyword">const</span> linkedBinaryTree&lt;E&gt;&amp; theTree)</span><br><span class="line">&#123;</span><br><span class="line">copy(root, theTree.root);</span><br><span class="line">treeSize = theTree.treeSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::copy(binaryTreeNode&lt;E&gt;*&amp; subTree1, binaryTreeNode&lt;E&gt;* subTree2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">subTree1 = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(subTree2-&gt;element);</span><br><span class="line">copy(subTree1-&gt;left, subTree2-&gt;left);</span><br><span class="line">copy(subTree1-&gt;right, subTree2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:非递归写法自行实现。</p></blockquote></li><li><input disabled="" type="checkbox"> Page284,T45:比较两棵树。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> linkedBinaryTree&lt;E&gt;&amp; theTree)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> compare(root, theTree.root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree1,binaryTreeNode&lt;E&gt;* subTree2)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">bool</span> linkedBinaryTree&lt;E&gt;::compare(binaryTreeNode&lt;E&gt;* subTree1, binaryTreeNode&lt;E&gt;* subTree2) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span> &amp;&amp; subTree2 != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (subTree1 != <span class="literal">nullptr</span> &amp;&amp; subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span> &amp;&amp; subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (subTree1-&gt;element != subTree2-&gt;element) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> compare(subTree1-&gt;left, subTree2-&gt;left) &amp;&amp; compare(subTree1-&gt;right, subTree2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度:$$O(n).$$<blockquote><p>Tips:非递归写法自行实现。</p></blockquote></li><li><input disabled="" type="checkbox"> Page284,T46:交换每个节点的左右子树。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapTrees</span><span class="params">()</span> </span>&#123; swapTrees(root-&gt;left, root-&gt;right); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapTrees</span><span class="params">(binaryTreeNode&lt;E&gt;*&amp; subTree1, binaryTreeNode&lt;E&gt;*&amp; subTree2)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::swapTrees(binaryTreeNode&lt;E&gt;*&amp; subTree1, binaryTreeNode&lt;E&gt;*&amp; subTree2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span> &amp;&amp; subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">swap(subTree1, subTree2);</span><br><span class="line"><span class="keyword">if</span> (subTree1 != <span class="literal">nullptr</span>) swapTrees(subTree1-&gt;left, subTree1-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (subTree2 != <span class="literal">nullptr</span>) swapTrees(subTree2-&gt;left, subTree2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度$$O(n).$$<blockquote><p>Tips:非递归写法自行实现。</p></blockquote></li><li><input disabled="" type="checkbox"> Page284,T47:计算左右子树的最大高度差。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxHeightDifference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> maxHeightDifference(root-&gt;left,root-&gt;right); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxHeightDifference</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree1, binaryTreeNode&lt;E&gt;* subTree2)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">int</span> linkedBinaryTree&lt;E&gt;::maxHeightDifference(binaryTreeNode&lt;E&gt;* subTree1, binaryTreeNode&lt;E&gt;* subTree2) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> height(subTree2);</span><br><span class="line"><span class="keyword">if</span> (subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> height(subTree1);</span><br><span class="line"><span class="keyword">int</span> h1 = height(subTree1);</span><br><span class="line"><span class="keyword">int</span> h2 = height(subTree2);</span><br><span class="line"><span class="keyword">return</span> max(<span class="built_in">abs</span>(h1 - h2), max(maxHeightDifference(subTree1-&gt;left, subTree1-&gt;right), maxHeightDifference(subTree2-&gt;left, subTree2-&gt;right)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度:<br>$$T(h) = 2T(h-1)+h$$<br>$$ = 4T(h-2)+2\times(h-1)+h$$<br>$$……$$<br>$$ = 2^hT(0)+h+2^2 \times(h-1)+2^4 \times(h-2)+…..2^{h-1} \times 1 $$<br>$$ h = \log n,T(0) = \varTheta (1) $$<br>$$ 得T(h) = O(n^2\times \log n). $$</li><li><input disabled="" type="checkbox"> Page284,T48:</li></ul><h2 id="信号放大器"><a href="#信号放大器" class="headerlink" title="信号放大器"></a>信号放大器</h2><ul><li><p><input disabled="" type="checkbox">  信号放大器使得节点的信号值与源点相同。</p></li><li><p>关于信号放大器的细节参见教材。</p></li><li><p>信号是一种抽象概念，它可以指代诸多事物。</p></li><li><p>书本上的信号放大器以二叉树表示，实际中网络会更加庞大复杂，此时树可以是多叉树。具体实现可以用孩子-兄弟表示法等等。</p></li><li><p>信号放大器每个节点有: $$degradeToLeaf(i) = \max\limits_{j是i的一个孩子}\lbrace degradeToLeaf(j)+degradeFromParent(j) \rbrace$$</p></li><li><p>当某点degradeToLeaf大于容忍值时，应该在此点放置信号放大器。</p></li><li><p>算法伪码如下(书上那个不叫伪代码吧…)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node = <span class="number">0</span> --&gt; n <span class="keyword">do</span></span><br><span class="line">degradeToLeaf(node) &lt;-- <span class="number">0</span></span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line"><span class="keyword">for</span> child of each node <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> degradeToLeaf(i)+degradeFromParent(j) &gt; 容忍值 then</span><br><span class="line">degradeToLeaf(i) &lt;-- max&#123; degradeToLeaf(i),degradeFromParent(j) &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">degradeToLeaf(i) &lt;-- max&#123; degradeToLeaf(i),degradeFromParent(j)+degradeToLeaf(j) &#125;</span><br><span class="line">end <span class="keyword">if</span></span><br></pre></td></tr></table></figure></li><li><p>接下来照搬书上的源代码。</p></li><li><p>每个节点的数据域定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并查集及其应用-某OJ上的奇妙经历"><a href="#并查集及其应用-某OJ上的奇妙经历" class="headerlink" title="并查集及其应用: 某OJ上的奇妙经历"></a>并查集及其应用: 某OJ上的奇妙经历</h2></li><li><p><input disabled="" type="checkbox">  并查集解决的是一类不相交集合的合并和查找问题。</p></li><li><p>书上的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(fu)</span></span><br><span class="line"><span class="keyword">int</span>* parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[numberOfElements + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfElements; i++) parent[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> theElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parent[theElement] != <span class="number">0</span>)</span><br><span class="line">theElement = parent[theElement];</span><br><span class="line"><span class="keyword">return</span> theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> rootA, <span class="keyword">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">parent[rootB] = rootA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入元素个数:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">initialize(n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; opt) &#123;</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> theElement;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入待查找的元素:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; theElement;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; theElement &lt;&lt; <span class="string">&quot; 的根是:&quot;</span> &lt;&lt; find(theElement) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> theElementA, theElementB;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入两个元素，合并它们所属的集合:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; theElementA &gt;&gt; theElementB;</span><br><span class="line"><span class="keyword">int</span> rootA = find(theElementA);</span><br><span class="line"><span class="keyword">int</span> rootB = find(theElementB);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;合并集合 &quot;</span> &lt;&lt; rootA &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; rootB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">unite(rootA, rootB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:未考虑程序鲁棒性。自行补充。</p></blockquote></li><li><p>时间复杂度: $$ O(fu) ，f是查找次数，u是合并次数。$$</p></li><li><p>重量规则和高度规则解决的实际上是如何选择合并后根节点的问题。</p></li><li><p>基于路径压缩和重量规则的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unionFindNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> parent;</span><br><span class="line"><span class="keyword">bool</span> root;</span><br><span class="line">unionFindNode() : parent(<span class="number">1</span>), root(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;*node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node = <span class="keyword">new</span> unionFindNode[numberOfElements + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1</span><span class="params">(<span class="keyword">int</span> theElement)</span> <span class="comment">// without path compression</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!node[theElement].root)</span><br><span class="line">theElement = node[theElement].parent;</span><br><span class="line"><span class="keyword">return</span> theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find2</span><span class="params">(<span class="keyword">int</span> theElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> theRoot = theElement;</span><br><span class="line"><span class="keyword">while</span> (!node[theRoot].root)</span><br><span class="line">theRoot = node[theRoot].parent;</span><br><span class="line"><span class="keyword">while</span> (theElement != theRoot) &#123;</span><br><span class="line"><span class="keyword">int</span> parentNode = node[theElement].parent;</span><br><span class="line">node[theElement].parent = theRoot;</span><br><span class="line">theElement = parentNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> rootA, <span class="keyword">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node[rootA].parent &lt; node[rootB].parent) &#123;</span><br><span class="line">node[rootB].parent += node[rootA].parent;</span><br><span class="line">node[rootA].parent = rootB;</span><br><span class="line">node[rootA].root = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node[rootA].parent += node[rootB].parent;</span><br><span class="line">node[rootB].parent = rootA;</span><br><span class="line">node[rootB].root = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 输入元素个数:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">initialize(n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; opt) &#123;</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> theElement;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入待查找的元素:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; theElement;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; theElement &lt;&lt; <span class="string">&quot; 的根是:&quot;</span> &lt;&lt; find2(theElement) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> theElementA, theElementB;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入两个元素，合并它们所属的集合:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; theElementA &gt;&gt; theElementB;</span><br><span class="line"><span class="keyword">int</span> rootA = find2(theElementA);</span><br><span class="line"><span class="keyword">int</span> rootB = find2(theElementB);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;合并集合 &quot;</span> &lt;&lt; rootA &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; rootB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">unite(rootA, rootB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用启发式合并(重量规则)和路径压缩后为:$$O(f)，假设f&gt; u。$$</p></li><li><p>仅使用启发式合并为$$O(f\log n)。$$</p></li><li><p><input disabled="" type="checkbox">  切题环节:此部分不推荐花大量时间做，可以当作兴趣。<del>放在这纯粹是好玩</del>。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213"><strong>How many tables(HDUOJ)</strong></a>:ACM省选热身赛</p></li><li><p>参考题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> friends[maxn];</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) friends[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> aFriend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> theRoot = aFriend;</span><br><span class="line"><span class="keyword">while</span> (theRoot != friends[theRoot])</span><br><span class="line">theRoot = friends[theRoot];</span><br><span class="line"><span class="keyword">while</span> (aFriend != theRoot) &#123;</span><br><span class="line"><span class="keyword">int</span> itsParent = friends[aFriend];</span><br><span class="line">friends[aFriend] = theRoot;</span><br><span class="line">aFriend = itsParent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> rootA, <span class="keyword">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rootA == rootB) <span class="keyword">return</span>;</span><br><span class="line">friends[rootB] = rootA;</span><br><span class="line">M--; <span class="comment">// after each unite: M--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">initialize();</span><br><span class="line"><span class="keyword">while</span> (N--) &#123;</span><br><span class="line"><span class="keyword">int</span> fA, fB;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; fA &gt;&gt; fB;</span><br><span class="line"><span class="keyword">int</span> rootA = find(fA);</span><br><span class="line"><span class="keyword">int</span> rootB = find(fB);</span><br><span class="line">unite(rootA, rootB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:此题没有用重量规则。</p></blockquote></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232"><strong>畅通工程(HDUOJ)</strong></a>:浙大研究生复试上机考</p></li><li><p>参考题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">roadNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> parent;</span><br><span class="line"><span class="keyword">bool</span> root;</span><br><span class="line">roadNode() : parent(<span class="number">1</span>), root(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;*towns;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initiaize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">towns = <span class="keyword">new</span> roadNode[N + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> theTown)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> theRoot = theTown;</span><br><span class="line"><span class="keyword">while</span> (!towns[theRoot].root)</span><br><span class="line">theRoot = towns[theRoot].parent;</span><br><span class="line"><span class="keyword">while</span> (theTown != theRoot) &#123;</span><br><span class="line"><span class="keyword">int</span> parentTown = towns[theTown].parent;</span><br><span class="line">towns[theTown].parent = theRoot;</span><br><span class="line">theTown = parentTown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> theTown1, <span class="keyword">int</span> theTown2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (theTown1 == theTown2) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (towns[theTown1].parent &lt; towns[theTown2].parent) &#123;</span><br><span class="line">towns[theTown2].parent += towns[theTown1].parent;</span><br><span class="line">towns[theTown1].parent = theTown2;</span><br><span class="line">towns[theTown1].root = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">towns[theTown1].parent += towns[theTown2].parent;</span><br><span class="line">towns[theTown2].parent = theTown1;</span><br><span class="line">towns[theTown2].root = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">N--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">while</span> (N) &#123;</span><br><span class="line">initiaize();</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line"><span class="keyword">while</span> (M--) &#123;</span><br><span class="line"><span class="keyword">int</span> t1, t2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line"><span class="keyword">int</span> root1 = find(t1);</span><br><span class="line"><span class="keyword">int</span> root2 = find(t2);</span><br><span class="line"> unite(root1, root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; N - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>[]towns;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:用scanf读入速度更快。(大约是cin的$\dfrac {1}{4}$)</p></blockquote></li><li><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/"><strong>最长连续序列</strong></a>:leetcode</p></li><li><p>参考题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting <span class="keyword">for</span> supplement......</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-islands/"><strong>岛屿数量</strong></a>:leetcode</p></li><li><p>参考题解1:Oh首先想到的难道真的是UF吗……康康BFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> offset[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; land;</span><br><span class="line">                    land.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                    <span class="keyword">while</span> (!land.empty()) &#123;</span><br><span class="line">                        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; xy = land.front();</span><br><span class="line">                        land.pop();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; newXy;</span><br><span class="line">                            newXy.first = xy.first + offset[k][<span class="number">0</span>];</span><br><span class="line">                            newXy.second = xy.second + offset[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (newXy.first &gt;= <span class="number">0</span> &amp;&amp; newXy.first &lt; grid.size() &amp;&amp; newXy.second &gt;= <span class="number">0</span> &amp;&amp; newXy.second &lt; grid[i].size()) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (grid[newXy.first][newXy.second] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                                    land.push(newXy);</span><br><span class="line">                                    grid[newXy.first][newXy.second] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>时间复杂度:$$O(n^2).$$</p></li><li><p>哦那试试DFS?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.size() || y &lt; <span class="number">0</span> || y &gt;= grid[x].size() || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,x,y+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,x+<span class="number">1</span>,y);</span><br><span class="line">        dfs(grid,x,y<span class="number">-1</span>);</span><br><span class="line">        dfs(grid,x<span class="number">-1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.size();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[i].size();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                   dfs(grid,i,j);</span><br><span class="line">                   cnt++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>时间复杂度$$O(n^2).$$</p></li><li><p>并查集写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting <span class="keyword">for</span> supplement......</span><br></pre></td></tr></table></figure></li></ul><h2 id="习题答案，P295，296"><a href="#习题答案，P295，296" class="headerlink" title="习题答案，P295，296"></a>习题答案，P295，296</h2><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h2 id="竞赛树"><a href="#竞赛树" class="headerlink" title="竞赛树"></a>竞赛树</h2><h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><h2 id="平衡搜索树"><a href="#平衡搜索树" class="headerlink" title="平衡搜索树"></a>平衡搜索树</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="分裂树"><a href="#分裂树" class="headerlink" title="分裂树"></a>分裂树</h2><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><h2 id="珂朵莉树"><a href="#珂朵莉树" class="headerlink" title="珂朵莉树"></a>珂朵莉树</h2><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><h2 id="析合树"><a href="#析合树" class="headerlink" title="析合树"></a>析合树</h2><h2 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h2><h2 id="朋友推荐的好听的歌"><a href="#朋友推荐的好听的歌" class="headerlink" title="朋友推荐的好听的歌!"></a>朋友推荐的好听的歌!</h2><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1396205229&auto=1&height=66"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法习题答案(机械工业出版社)" scheme="http://joe-sdu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>关于数据结构与算法的一点约定</title>
    <link href="http://joe-sdu.top/2020/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E5%89%8D%E8%A8%80/"/>
    <id>http://joe-sdu.top/2020/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E5%89%8D%E8%A8%80/</id>
    <published>2020-11-10T04:28:49.000Z</published>
    <updated>2020-11-15T14:06:41.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码约定"><a href="#代码约定" class="headerlink" title="代码约定"></a>代码约定</h2><ul><li><input disabled="" type="checkbox"> 代码块统一采用Times New Roman字体，点击右上角即可复制。</li><li><input disabled="" type="checkbox"> 代码在MSVC上编译通过，理论上只要环境相同copy下来就能跑。<a id="more"></a><blockquote><p>我的编译环境: </p></blockquote></li><li>IDE: Microsoft Visual Studio 2019</li><li>Target: x86_64-w64-mingw32</li><li>gcc: gcc version 8.1.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project)</li></ul><h2 id="答案约定"><a href="#答案约定" class="headerlink" title="答案约定"></a>答案约定</h2><ul><li><input disabled="" type="checkbox"> 有错的答案请私信回复我哈。</li></ul><h2 id="重复代码约定"><a href="#重复代码约定" class="headerlink" title="重复代码约定"></a>重复代码约定</h2><ul><li><input disabled="" type="checkbox"> 如果某代码在前面已经给出，后面不再赘述，只是简单提及。</li></ul><h2 id="题目顺序约定"><a href="#题目顺序约定" class="headerlink" title="题目顺序约定"></a>题目顺序约定</h2><ul><li><input disabled="" type="checkbox"> 题目不会按照第一题到最后一题的顺序给出，而是在比较自然的地方引入。题目前会标注题号。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;代码约定&quot;&gt;&lt;a href=&quot;#代码约定&quot; class=&quot;headerlink&quot; title=&quot;代码约定&quot;&gt;&lt;/a&gt;代码约定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 代码块统一采用Times New Roman字体，点击右上角即可复制。&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 代码在MSVC上编译通过，理论上只要环境相同copy下来就能跑。</summary>
    
    
    
    <category term="数据结构与算法习题答案(机械工业出版社)" scheme="http://joe-sdu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE/"/>
    
    
  </entry>
  
</feed>
