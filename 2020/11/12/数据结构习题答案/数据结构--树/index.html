<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"joe-sdu.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/index.html">
<meta property="og:site_name" content="Joe&#39;s blog">
<meta property="og:description" content="鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-12T04:28:49.000Z">
<meta property="article:modified_time" content="2020-11-19T03:06:26.788Z">
<meta property="article:author" content="Joe-sdu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>树 | Joe's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Joe's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Joe's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>小徐的首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>博客分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>博客归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Joe-sdu">
      <meta itemprop="description" content="Joe永远爱生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joe's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          树
        </h1>

        <div class="post-meta">
            
              <i class="fa fa-thumb-tack"></i>
              <font color=7D26CD>置顶</font>
              <span class="post-meta-divider">|</span>
            
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-12 12:28:49" itemprop="dateCreated datePublished" datetime="2020-11-12T12:28:49+08:00">2020-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-19 11:06:26" itemprop="dateModified" datetime="2020-11-19T11:06:26+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">藏于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E6%9C%BA%E6%A2%B0%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法习题答案(机械工业出版社)</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p>
<a id="more"></a>
<h2 id="二叉树和其他树"><a href="#二叉树和其他树" class="headerlink" title="二叉树和其他树"></a>二叉树和其他树</h2><blockquote>
<p>Tips:先把书上的代码弄出来吧~</p>
</blockquote>
<ul>
<li><p>层序遍历用到了队列</p>
</li>
<li><p>队列实现自行参考之前的队列章节</p>
</li>
<li><p><input disabled="" type="checkbox">  类的实现: 让树生根发芽<br>二叉树的ADT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BINARYTREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARYTREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Pure virtual base class: all other kinds of tree derived from it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~binaryTree() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">void</span> (*)(T*))</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">void</span> (*)(T*))</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">void</span> (*)(T*))</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Explanation: </span></span><br><span class="line"><span class="comment">	some of you may ask this: why our travelsal functions can&#x27;t be &#x27;const&#x27;.</span></span><br><span class="line"><span class="comment">	We should know the fact: travelsal doesn&#x27;t mean see the element,we can</span></span><br><span class="line"><span class="comment">	use those functions to change the tree, even delete it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>链表二叉树的链表节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BINARYTREENODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINARYTREENODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	When decided to make a structure with linked list,the first step is to make its node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T element;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* left, * right;</span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	binaryTreeNode() : element(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	binaryTreeNode(<span class="keyword">const</span> T&amp; theElement) : element(theElement), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	binaryTreeNode(<span class="keyword">const</span> T&amp; theElement, binaryTreeNode&lt;T&gt;* theLeft, binaryTreeNode&lt;T&gt;* theRight)</span><br><span class="line">		: element(theElement), left(theLeft), right(theRight) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>链表二叉树的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKED_BINARY_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKED_BINARY_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binaryTreeNode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binaryTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s a great habit--not using &#x27;namespace std&#x27; in a header file.</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.Details: binaryTree&lt;binaryTreeNode&lt;E&gt;&gt; should be written as:</span></span><br><span class="line"><span class="comment">	binaryTree&lt;binaryTreeNode&lt;E&gt; &gt; (add a space at the end)</span></span><br><span class="line"><span class="comment">	if the version of your C++ is not C++11, for example: C++98.</span></span><br><span class="line"><span class="comment">	2.Static pointer &#x27;dynamicVisit&#x27; can be changed! That is how we</span></span><br><span class="line"><span class="comment">	change our method when use traversal functions.</span></span><br><span class="line"><span class="comment">	3.We use static functions to operate our traversal functions,</span></span><br><span class="line"><span class="comment">	this seems a little cumbersome. But in fact, we can never let our</span></span><br><span class="line"><span class="comment">	users(other programmers) to pass a pointer to our function! They even</span></span><br><span class="line"><span class="comment">	don&#x27;t know where is our root. This is called packaging.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="comment">// E standardize for element</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedBinaryTree</span> :</span> <span class="keyword">public</span> binaryTree&lt;binaryTreeNode&lt;E&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~linkedBinaryTree() &#123; postOrder(dispose); root = <span class="literal">nullptr</span>; treeSize = <span class="number">0</span>; &#125;</span><br><span class="line">	linkedBinaryTree() &#123; root = <span class="literal">nullptr</span>; treeSize = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> treeSize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> treeSize; &#125;</span><br><span class="line">	<span class="comment">// Inline type, overloded</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span> </span>&#123; dynamicVisit = visit; preOrder(root); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span> </span>&#123; dynamicVisit = visit; inOrder(root); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span> </span>&#123; dynamicVisit = visit; postOrder(root); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	binaryTreeNode&lt;E&gt;* root;</span><br><span class="line">	<span class="keyword">int</span> treeSize;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*dynamicVisit)</span> <span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>; <span class="comment">// default nullptr, no target.</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span> </span>&#123; <span class="keyword">delete</span> subTree; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declaration of static member</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> (*linkedBinaryTree&lt;E&gt;::dynamicVisit) (binaryTreeNode&lt;E&gt;* subTree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Below are traversal functions, pay attention to their overloded type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pre-Order traversal: recursion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::preOrder(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		linkedBinaryTree&lt;E&gt;::dynamicVisit(subTree);</span><br><span class="line">		preOrder(subTree-&gt;left);</span><br><span class="line">		preOrder(subTree-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In-Order traversal: recursion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::inOrder(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		preOrder(subTree-&gt;left);</span><br><span class="line">		linkedBinaryTree&lt;E&gt;::dynamicVisit(subTree);</span><br><span class="line">		preOrder(subTree-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post-Order traversal: recursion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::postOrder(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		postOrder(subTree-&gt;left);</span><br><span class="line">		postOrder(subTree-&gt;right);</span><br><span class="line">		linkedBinaryTree&lt;E&gt;::dynamicVisit(subTree);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::levelOrder(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">	linkedBinaryTree&lt;E&gt;::dynamicVisit = visit;</span><br><span class="line">	binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">	arrayQueue&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">	<span class="keyword">while</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		linkedBinaryTree&lt;E&gt;::dynamicVisit(currNode);</span><br><span class="line">		<span class="keyword">if</span> (currNode-&gt;left != <span class="literal">nullptr</span>) treeBucket.push(currNode-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (currNode-&gt;right != <span class="literal">nullptr</span>) treeBucket.push(currNode-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (!treeBucket.empty()) &#123;</span><br><span class="line">			currNode = treeBucket.front();</span><br><span class="line">			treeBucket.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> currNode = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>实际上，到这一步之后，我们的二叉树类还完全没法用起来，原因在于，我们没法构建一棵树，而且在遍历的时候我们还未规定方法。<br>但是如上的框架已经可以称作一个比较完整的类了，后续的操作都在它上面展开。</p>
</li>
<li><p>关键一步: 造树</p>
<blockquote>
<p>造树的方法有很多很多，可以采用不断插入节点的方式，也可以采用合并树的方式，这里我们采用后者。前者在B树实现时我们再详细说。</p>
</blockquote>
</li>
<li><p>公有声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> theElement,linkedBinaryTree&lt;E&gt;&amp; leftTree, linkedBinaryTree&lt;E&gt;&amp; rightTree)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::makeTree(<span class="keyword">int</span> theElement, linkedBinaryTree&lt;E&gt;&amp; leftTree, linkedBinaryTree&lt;E&gt;&amp; rightTree)</span><br><span class="line">&#123;</span><br><span class="line">	root = <span class="keyword">new</span> binaryTreeNode&lt;E&gt; * (theElement, leftTree.root, rightTree.root);</span><br><span class="line">	leftTree.root = rightTree.root = <span class="literal">nullptr</span>;</span><br><span class="line">	treeSize = leftTree.treeSize + rightTree.treeSize + <span class="number">1</span>;</span><br><span class="line">	leftTree.treeSize = rightTree.treeSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历操作: 遍历通过dynamicVisit进行灵活转换，后续大部分操作都得借助它，举个例子:如果遍历时只是简单输出。那么我们可以给公有遍历函数传如下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(binaryTreeNode&lt;T&gt;* subTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; subTree-&gt;element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到这一步后，理论上如果你和我的编译环境差距不大，都是可以种出一棵树的。接下来的工作都是美化树了，我们会给出实际例子。</p>
</blockquote>
</li>
</ul>
<h2 id="习题答案，P280、281"><a href="#习题答案，P280、281" class="headerlink" title="习题答案，P280、281"></a>习题答案，P280、281</h2><ul>
<li><p><input disabled="" type="checkbox">  Page280，T20，数组实现的二叉树的前序遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> arrayTree&lt;T&gt;::preOrder(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; arraySize &amp;&amp; tree[index].first != <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tree[index].second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		preOrder(<span class="number">2</span> * index);</span><br><span class="line">		preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayTree&lt;T&gt;::preOrder()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (treeSize == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The tree is empty!&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;前序遍历:&quot;</span>;</span><br><span class="line">	preOrder(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记得加入声明</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>数据类型表示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">bool</span>, T&gt;* tree;</span><br><span class="line"><span class="keyword">int</span> treeSize; <span class="comment">// number of nodes</span></span><br><span class="line"><span class="keyword">int</span> arraySize; <span class="comment">// length of array</span></span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度:$$ O(n). $$</p>
</li>
<li><p><input disabled="" type="checkbox">  Page281，T27，计算高度</p>
</li>
<li><p>私有声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>公有接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> height(root); &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">int</span> linkedBinaryTree&lt;E&gt;::height(binaryTreeNode&lt;E&gt;* subTree)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> h1 = height(subTree-&gt;left);</span><br><span class="line">	<span class="keyword">int</span> h2 = height(subTree-&gt;right);</span><br><span class="line">	<span class="keyword">if</span> (h1 &lt;= h2) <span class="keyword">return</span> ++h2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ++h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度<br>$$T(h) = 2\times T(h-1)$$<br>$$= 4\times T(h-1)$$<br>$$= ……$$<br>$$= 2^k\times T(0)$$<br>$$= 2^k$$<br>$$k = \log_2 n, 所以T(h) = O(n).$$</p>
</li>
<li><p>空间复杂度<br>$$ 递归深度H = \log_2 n $$<br>$$ 故有S(n) = O(\log_2 n) = O(h) $$</p>
</li>
<li><p><input disabled="" type="checkbox">  Page281，T28，求节点个数</p>
<blockquote>
<p>实际上我们上面的size函数已经能实现该功能了，但是写写也无妨奥，方法也很简单。</p>
</blockquote>
</li>
<li><p>声明1:全局的cnt计数器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt;</span><br></pre></td></tr></table></figure></li>
<li><p>定义2:递增函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ascend</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree)</span> </span>&#123; cnt++; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义:公有方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNode</span><span class="params">()</span> </span>&#123; cnt = <span class="number">0</span>; preOrder(ascend); <span class="keyword">return</span> cnt; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:如果直接把cnt定义成静态私有成员会报错，如果把ascend定义成非static函数会报错。</p>
</blockquote>
</li>
<li><p>时间复杂度:<br>$$ O(n) $$</p>
</li>
<li><p><input disabled="" type="checkbox">  Page281，T29，判断哪一层具有最多的节点</p>
</li>
<li><p>使用层次遍历，但是不能直接调用已有方法，而是重写一遍。</p>
</li>
<li><p>把如下声明加入公有方法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLevel</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extensive Level-Order travelsal</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">int</span> linkedBinaryTree&lt;E&gt;::findMaxLevel() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">	arrayQueue&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">	treeBucket.push(currNode);</span><br><span class="line">	<span class="keyword">int</span> maxNode = <span class="number">0</span>, maxLevel = <span class="number">0</span>, level = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!treeBucket.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> capacity = treeBucket.size();</span><br><span class="line">		<span class="keyword">if</span> (capacity &gt; maxNode) &#123;</span><br><span class="line">			maxLevel = level; </span><br><span class="line">			maxNode = capacity;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= capacity; i++) &#123; <span class="comment">// impossible to make an exception,think twice </span></span><br><span class="line">			binaryTreeNode&lt;E&gt;* tempNode = treeBucket.front();</span><br><span class="line">			treeBucket.pop();</span><br><span class="line">			<span class="keyword">if</span> (tempNode-&gt;left != <span class="literal">nullptr</span>) treeBucket.push(tempNode-&gt;left);</span><br><span class="line">			<span class="keyword">if</span> (tempNode-&gt;right != <span class="literal">nullptr</span>) treeBucket.push(tempNode-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		level++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 上述方法是自洽的，循环中不会出现队列抛出异常。</p>
</blockquote>
</li>
<li><p>时间复杂度:<br>$$ O(n)，每个节点只会入队一次. $$</p>
</li>
<li><p><input disabled="" type="checkbox">  Page281，T30-32:三题思路一致，故不分开写。栈的实现参考之前的文章。</p>
<blockquote>
<p>Tips:别忘了在头文件中包含stack!</p>
</blockquote>
</li>
<li><p>T30:中序遍历:不用递归就用栈，能用递归往往就能用栈实现，此题关键在于何时拐弯(如果遍历是在树中散步的话)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::inOrderWithoutRecursion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">	arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">	binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">	<span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			treeBucket.push(currNode);</span><br><span class="line">			currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!treeBucket.empty()) &#123;</span><br><span class="line">			currNode = treeBucket.top();</span><br><span class="line">			treeBucket.pop();</span><br><span class="line">			visit(currNode);</span><br><span class="line">			currNode = currNode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>T31:前序遍历:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::preOrderWithoutRecursion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">	arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">	binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">	<span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			visit(currNode);</span><br><span class="line">			treeBucket.push(currNode);</span><br><span class="line">			currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!treeBucket.empty())&#123;</span><br><span class="line">			currNode = treeBucket.top();</span><br><span class="line">			treeBucket.pop();</span><br><span class="line">			currNode = currNode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>T32:后序遍历:体会其中的不同点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::postOrderWithoutRecursion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">	arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">	binaryTreeNode&lt;E&gt;* currNode = root, * lastNode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			treeBucket.push(currNode);</span><br><span class="line">			currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!treeBucket.empty()) &#123;</span><br><span class="line">			currNode = treeBucket.top();</span><br><span class="line">			<span class="keyword">if</span> (currNode-&gt;right == <span class="literal">nullptr</span> || currNode-&gt;right == lastNode) &#123;</span><br><span class="line">				treeBucket.pop();</span><br><span class="line">				visit(currNode);</span><br><span class="line">				lastNode = currNode;</span><br><span class="line">				currNode = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> currNode = currNode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>需要的栈空间大小等于沿着树枝散步时的最大路径长度，为O(h)。</p>
</li>
<li><p>其实上面的写法都有等价写法，这里给出前序遍历的等价写法，其他的类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::equivalentNotion(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span><br><span class="line">&#123;</span><br><span class="line">	arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket;</span><br><span class="line">	binaryTreeNode&lt;E&gt;* currNode = root;</span><br><span class="line">	<span class="keyword">while</span> (!treeBucket.empty() || currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(currNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			visit(currNode);</span><br><span class="line">			treeBucket.push(currNode);</span><br><span class="line">			currNode = currNode-&gt;left; <span class="comment">// Walk to left side</span></span><br><span class="line">		&#125;</span><br><span class="line">		currNode = treeBucket.top();</span><br><span class="line">		treeBucket.pop();</span><br><span class="line">		currNode = currNode-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上写法是自洽的，不会抛出异常。<br>记得在类的公有方法里加上四个声明:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderWithoutRecursion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equivalentNotion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderWithoutRecursion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderWithoutRecursion</span><span class="params">(<span class="keyword">void</span>(*visit)(binaryTreeNode&lt;E&gt;*))</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p><input disabled="" type="checkbox">  Page281、T33，34，35，三题思路一致，一起写。与此同时解决了T15-19(自己调用下就行了。爽欸都不用单独画图然后md了)，也不再单独说了。</p>
</li>
<li><p>T33:已知前序和中序求后序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::initWithPreOrderAndInOrder(E* pre, E* in, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">	treeSize = theSize;</span><br><span class="line">	root = initWithPreOrderAndInOrder(pre, <span class="number">0</span>, theSize - <span class="number">1</span>, in, <span class="number">0</span>, theSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">binaryTreeNode&lt;E&gt;* linkedBinaryTree&lt;E&gt;::initWithPostOrderAndInOrder(E* post, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, E* in, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pStart &gt; pEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// The end of recursion</span></span><br><span class="line">	binaryTreeNode&lt;E&gt;* newNode = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(post[pEnd]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (in[i] == post[pEnd]) &#123;</span><br><span class="line">			newNode-&gt;left = initWithPostOrderAndInOrder(post, pStart, pStart + i - inStart - <span class="number">1</span>, in, inStart, i - <span class="number">1</span>);</span><br><span class="line">			newNode-&gt;right = initWithPostOrderAndInOrder(post, pStart + i - inStart, pEnd - <span class="number">1</span>, in, i + <span class="number">1</span>, inEnd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>T34:已知后序和中序求前序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">binaryTreeNode&lt;E&gt;* linkedBinaryTree&lt;E&gt;::initWithPostOrderAndInOrder(E* post, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd, E* in, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pStart &gt; pEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// The end of recursion</span></span><br><span class="line">	binaryTreeNode&lt;E&gt;* newNode = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(post[pEnd]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (in[i] == post[pEnd]) &#123;</span><br><span class="line">			newNode-&gt;left = initWithPostOrderAndInOrder(post, pStart, pStart + i - inStart - <span class="number">1</span>, in, inStart, i - <span class="number">1</span>);</span><br><span class="line">			newNode-&gt;right = initWithPostOrderAndInOrder(post, pStart + i - inStart, pEnd - <span class="number">1</span>, in, i + <span class="number">1</span>, inEnd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::initWithPostOrderAndInOrder(E* post, E* in, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">	treeSize = theSize;</span><br><span class="line">	root = initWithPostOrderAndInOrder(post, <span class="number">0</span>, theSize - <span class="number">1</span>, in, <span class="number">0</span>, theSize - <span class="number">1</span>);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 同样要记得加声明啊喂!</p>
</blockquote>
</li>
<li><p>T35:已知后序和前序可以求中序，当且仅当以每个节点度为0或者2。(突如其来的机工腔)</p>
<blockquote>
<p>当存在度为1的节点时不一定能唯一确定一棵树，我们可以从仅含两个节点的树设想,以下结论恒成立:一个仅含2个节点的树，左偏的前序遍历、后序遍历和右偏相同。可以以第19题作为例子自己体会。</p>
</blockquote>
</li>
<li><p>时间复杂度</p>
</li>
<li><p>对于已知前序和中序时，最坏情况下，二叉树的各个节点均只有左子树，此时有:<br>$$ T(n) = T(n-1) + c_1\times n $$<br>$$ = T(n-1) + c_1\times n + c_2\times (n-1) $$<br>$$ = …… $$<br>$$ = T(0) + \dfrac {n\times (n+1)}{2} $$<br>$$ = O(n^2). $$</p>
</li>
<li><p>平均情况下，二叉树为满二叉树，此时:<br>$$ T(n) = 2\times T(\dfrac {n}{2}) + \dfrac {c\times n}{2} $$<br>由<strong>master’s theory</strong>知:<br>$$ T(n) = \varTheta (n\times \log n). $$</p>
<blockquote>
<p>Tips:master’s theory，又称主定理，具体可参考博文:主定理的应用。</p>
</blockquote>
</li>
<li><p>T36: 输入后缀表达式，构造二叉树表示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a tree by reverse poland notion, pass an array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::makeTreeByReversePolandNotion(E* rPoland, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">	treeSize = theSize;</span><br><span class="line">	arrayStack&lt;binaryTreeNode&lt;E&gt;*&gt; treeBucket; <span class="comment">// preserve subtrees</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theSize; i++) &#123;</span><br><span class="line">		binaryTreeNode&lt;E&gt;* tempTree = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(rPoland[i]); <span class="comment">// default: left-null,right-null</span></span><br><span class="line">		<span class="keyword">if</span> (rPoland[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; rPoland[i] &lt;= <span class="string">&#x27;9&#x27;</span>) treeBucket.push(tempTree);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (treeBucket.size() == <span class="number">1</span>) &#123;</span><br><span class="line">				tempTree-&gt;right = treeBucket.top();</span><br><span class="line">				treeBucket.pop();</span><br><span class="line">				treeBucket.push(tempTree);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tempTree-&gt;right = treeBucket.top();</span><br><span class="line">				treeBucket.pop();</span><br><span class="line">				tempTree-&gt;left = treeBucket.top();</span><br><span class="line">				treeBucket.pop();</span><br><span class="line">				treeBucket.push(tempTree);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root = treeBucket.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如上实现是存在问题的，请你根据自己的理解进行修改(问题并不在程序逻辑，逻辑本身完全正确)。</p>
</li>
<li><p>T37: 用前缀表达式构造二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>T38: 后缀表达式转完全括号化的中缀表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>实际上后缀表达式就是对表达式树进行后序遍历的结果，前缀表达式就是前序遍历的结果，中序同理。</p>
<blockquote>
<p>Tips:对前中后缀表达式不熟悉的话可以去栈章节找到关于前中后缀表达式的解释和实现。</p>
</blockquote>
</li>
<li><p>T40、T41参考栈章节，此处不再表述。</p>
</li>
<li><p>T42: 由中缀表达式得到二叉树形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>T43:计算后缀表达式的值，参考栈(稍作修改)，不再表述。</p>
</li>
</ul>
<h2 id="习题答案，P284、285"><a href="#习题答案，P284、285" class="headerlink" title="习题答案，P284、285"></a>习题答案，P284、285</h2><ul>
<li><input disabled="" type="checkbox"> Page284,T44:复制构造函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">linkedBinaryTree&lt;E&gt;::linkedBinaryTree(<span class="keyword">const</span> linkedBinaryTree&lt;E&gt;&amp; theTree)</span><br><span class="line">&#123;</span><br><span class="line">	copy(root, theTree.root);</span><br><span class="line">	treeSize = theTree.treeSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::copy(binaryTreeNode&lt;E&gt;*&amp; subTree1, binaryTreeNode&lt;E&gt;* subTree2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	subTree1 = <span class="keyword">new</span> binaryTreeNode&lt;E&gt;(subTree2-&gt;element);</span><br><span class="line">	copy(subTree1-&gt;left, subTree2-&gt;left);</span><br><span class="line">	copy(subTree1-&gt;right, subTree2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:非递归写法自行实现。</p>
</blockquote>
</li>
<li><input disabled="" type="checkbox"> Page284,T45:比较两棵树。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> linkedBinaryTree&lt;E&gt;&amp; theTree)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> compare(root, theTree.root); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree1,binaryTreeNode&lt;E&gt;* subTree2)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">bool</span> linkedBinaryTree&lt;E&gt;::compare(binaryTreeNode&lt;E&gt;* subTree1, binaryTreeNode&lt;E&gt;* subTree2) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span> &amp;&amp; subTree2 != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (subTree1 != <span class="literal">nullptr</span> &amp;&amp; subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span> &amp;&amp; subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (subTree1-&gt;element != subTree2-&gt;element) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> compare(subTree1-&gt;left, subTree2-&gt;left) &amp;&amp; compare(subTree1-&gt;right, subTree2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度:$$O(n).$$<blockquote>
<p>Tips:非递归写法自行实现。</p>
</blockquote>
</li>
<li><input disabled="" type="checkbox"> Page284,T46:交换每个节点的左右子树。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapTrees</span><span class="params">()</span> </span>&#123; swapTrees(root-&gt;left, root-&gt;right); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapTrees</span><span class="params">(binaryTreeNode&lt;E&gt;*&amp; subTree1, binaryTreeNode&lt;E&gt;*&amp; subTree2)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> linkedBinaryTree&lt;E&gt;::swapTrees(binaryTreeNode&lt;E&gt;*&amp; subTree1, binaryTreeNode&lt;E&gt;*&amp; subTree2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span> &amp;&amp; subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	swap(subTree1, subTree2);</span><br><span class="line">	<span class="keyword">if</span> (subTree1 != <span class="literal">nullptr</span>) swapTrees(subTree1-&gt;left, subTree1-&gt;right);</span><br><span class="line">	<span class="keyword">if</span> (subTree2 != <span class="literal">nullptr</span>) swapTrees(subTree2-&gt;left, subTree2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度$$O(n).$$<blockquote>
<p>Tips:非递归写法自行实现。</p>
</blockquote>
</li>
<li><input disabled="" type="checkbox"> Page284,T47:计算左右子树的最大高度差。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxHeightDifference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> maxHeightDifference(root-&gt;left,root-&gt;right); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxHeightDifference</span><span class="params">(binaryTreeNode&lt;E&gt;* subTree1, binaryTreeNode&lt;E&gt;* subTree2)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">int</span> linkedBinaryTree&lt;E&gt;::maxHeightDifference(binaryTreeNode&lt;E&gt;* subTree1, binaryTreeNode&lt;E&gt;* subTree2) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (subTree1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> height(subTree2);</span><br><span class="line">	<span class="keyword">if</span> (subTree2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> height(subTree1);</span><br><span class="line">	<span class="keyword">int</span> h1 = height(subTree1);</span><br><span class="line">	<span class="keyword">int</span> h2 = height(subTree2);</span><br><span class="line">	<span class="keyword">return</span> max(<span class="built_in">abs</span>(h1 - h2), max(maxHeightDifference(subTree1-&gt;left, subTree1-&gt;right), maxHeightDifference(subTree2-&gt;left, subTree2-&gt;right)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度:<br>$$T(h) = 2T(h-1)+h$$<br>$$ = 4T(h-2)+2\times(h-1)+h$$<br>$$……$$<br>$$ = 2^hT(0)+h+2^2 \times(h-1)+2^4 \times(h-2)+…..2^{h-1} \times 1 $$<br>$$ h = \log n,T(0) = \varTheta (1) $$<br>$$ 得T(h) = O(n^2\times \log n). $$</li>
<li><input disabled="" type="checkbox"> Page284,T48:</li>
</ul>
<h2 id="信号放大器"><a href="#信号放大器" class="headerlink" title="信号放大器"></a>信号放大器</h2><ul>
<li><p><input disabled="" type="checkbox">  信号放大器使得节点的信号值与源点相同。</p>
</li>
<li><p>关于信号放大器的细节参见教材。</p>
</li>
<li><p>信号是一种抽象概念，它可以指代诸多事物。</p>
</li>
<li><p>书本上的信号放大器以二叉树表示，实际中网络会更加庞大复杂，此时树可以是多叉树。具体实现可以用孩子-兄弟表示法等等。</p>
</li>
<li><p>信号放大器每个节点有: $$degradeToLeaf(i) = \max\limits_{j是i的一个孩子}\lbrace degradeToLeaf(j)+degradeFromParent(j) \rbrace$$</p>
</li>
<li><p>当某点degradeToLeaf大于容忍值时，应该在此点放置信号放大器。</p>
</li>
<li><p>算法伪码如下(书上那个不叫伪代码吧…)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> node = <span class="number">0</span> --&gt; n <span class="keyword">do</span></span><br><span class="line">	degradeToLeaf(node) &lt;-- <span class="number">0</span></span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line"><span class="keyword">for</span> child of each node <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> degradeToLeaf(i)+degradeFromParent(j) &gt; 容忍值 then</span><br><span class="line">		degradeToLeaf(i) &lt;-- max&#123; degradeToLeaf(i),degradeFromParent(j) &#125;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		degradeToLeaf(i) &lt;-- max&#123; degradeToLeaf(i),degradeFromParent(j)+degradeToLeaf(j) &#125;</span><br><span class="line">	end <span class="keyword">if</span></span><br></pre></td></tr></table></figure></li>
<li><p>接下来照搬书上的源代码。</p>
</li>
<li><p>每个节点的数据域定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="并查集及其应用-某OJ上的奇妙经历"><a href="#并查集及其应用-某OJ上的奇妙经历" class="headerlink" title="并查集及其应用: 某OJ上的奇妙经历"></a>并查集及其应用: 某OJ上的奇妙经历</h2></li>
<li><p><input disabled="" type="checkbox">  并查集解决的是一类不相交集合的合并和查找问题。</p>
</li>
<li><p>书上的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(fu)</span></span><br><span class="line"><span class="keyword">int</span>* parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	parent = <span class="keyword">new</span> <span class="keyword">int</span>[numberOfElements + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfElements; i++) parent[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> theElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (parent[theElement] != <span class="number">0</span>)</span><br><span class="line">		theElement = parent[theElement];</span><br><span class="line">	<span class="keyword">return</span> theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> rootA, <span class="keyword">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	parent[rootB] = rootA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入元素个数:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	initialize(n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> opt;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; opt) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> theElement;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入待查找的元素:&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; theElement;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; theElement &lt;&lt; <span class="string">&quot; 的根是:&quot;</span> &lt;&lt; find(theElement) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> theElementA, theElementB;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入两个元素，合并它们所属的集合:&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; theElementA &gt;&gt; theElementB;</span><br><span class="line">			<span class="keyword">int</span> rootA = find(theElementA);</span><br><span class="line">			<span class="keyword">int</span> rootB = find(theElementB);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;合并集合 &quot;</span> &lt;&lt; rootA &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; rootB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			unite(rootA, rootB);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:未考虑程序鲁棒性。自行补充。</p>
</blockquote>
</li>
<li><p>时间复杂度: $$ O(fu) ，f是查找次数，u是合并次数。$$</p>
</li>
<li><p>重量规则和高度规则解决的实际上是如何选择合并后根节点的问题。</p>
</li>
<li><p>基于路径压缩和重量规则的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unionFindNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">	<span class="keyword">bool</span> root;</span><br><span class="line">	unionFindNode() : parent(<span class="number">1</span>), root(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;*node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node = <span class="keyword">new</span> unionFindNode[numberOfElements + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1</span><span class="params">(<span class="keyword">int</span> theElement)</span> <span class="comment">// without path compression</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!node[theElement].root)</span><br><span class="line">		theElement = node[theElement].parent;</span><br><span class="line">	<span class="keyword">return</span> theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find2</span><span class="params">(<span class="keyword">int</span> theElement)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> theRoot = theElement;</span><br><span class="line">	<span class="keyword">while</span> (!node[theRoot].root)</span><br><span class="line">		theRoot = node[theRoot].parent;</span><br><span class="line">	<span class="keyword">while</span> (theElement != theRoot) &#123;</span><br><span class="line">		<span class="keyword">int</span> parentNode = node[theElement].parent;</span><br><span class="line">		node[theElement].parent = theRoot;</span><br><span class="line">		theElement = parentNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> rootA, <span class="keyword">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node[rootA].parent &lt; node[rootB].parent) &#123;</span><br><span class="line">		node[rootB].parent += node[rootA].parent;</span><br><span class="line">		node[rootA].parent = rootB;</span><br><span class="line">		node[rootA].root = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		node[rootA].parent += node[rootB].parent;</span><br><span class="line">		node[rootB].parent = rootA;</span><br><span class="line">		node[rootB].root = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 输入元素个数:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	initialize(n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> opt;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; opt) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> theElement;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入待查找的元素:&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; theElement;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; theElement &lt;&lt; <span class="string">&quot; 的根是:&quot;</span> &lt;&lt; find2(theElement) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> theElementA, theElementB;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入两个元素，合并它们所属的集合:&quot;</span>;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; theElementA &gt;&gt; theElementB;</span><br><span class="line">			<span class="keyword">int</span> rootA = find2(theElementA);</span><br><span class="line">			<span class="keyword">int</span> rootB = find2(theElementB);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;合并集合 &quot;</span> &lt;&lt; rootA &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; rootB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			unite(rootA, rootB);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入操作 1)查找 2)合并:&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用启发式合并(重量规则)和路径压缩后为:$$O(f)，假设f&gt; u。$$</p>
</li>
<li><p>仅使用启发式合并为$$O(f\log n)。$$</p>
</li>
<li><p><input disabled="" type="checkbox">  切题环节:此部分不推荐花大量时间做，可以当作兴趣。<del>放在这纯粹是好玩</del>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1213"><strong>How many tables(HDUOJ)</strong></a>:ACM省选热身赛</p>
</li>
<li><p>参考题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> friends[maxn];</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) friends[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> aFriend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> theRoot = aFriend;</span><br><span class="line">	<span class="keyword">while</span> (theRoot != friends[theRoot])</span><br><span class="line">		theRoot = friends[theRoot];</span><br><span class="line">	<span class="keyword">while</span> (aFriend != theRoot) &#123;</span><br><span class="line">		<span class="keyword">int</span> itsParent = friends[aFriend];</span><br><span class="line">		friends[aFriend] = theRoot;</span><br><span class="line">		aFriend = itsParent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> rootA, <span class="keyword">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rootA == rootB) <span class="keyword">return</span>;</span><br><span class="line">	friends[rootB] = rootA;</span><br><span class="line">	M--; <span class="comment">// after each unite: M--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> N;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">		initialize();</span><br><span class="line">		<span class="keyword">while</span> (N--) &#123;</span><br><span class="line">			<span class="keyword">int</span> fA, fB;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; fA &gt;&gt; fB;</span><br><span class="line">			<span class="keyword">int</span> rootA = find(fA);</span><br><span class="line">			<span class="keyword">int</span> rootB = find(fB);</span><br><span class="line">			unite(rootA, rootB);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:此题没有用重量规则。</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1232"><strong>畅通工程(HDUOJ)</strong></a>:浙大研究生复试上机考</p>
</li>
<li><p>参考题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">roadNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">	<span class="keyword">bool</span> root;</span><br><span class="line">	roadNode() : parent(<span class="number">1</span>), root(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;*towns;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initiaize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	towns = <span class="keyword">new</span> roadNode[N + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> theTown)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> theRoot = theTown;</span><br><span class="line">	<span class="keyword">while</span> (!towns[theRoot].root)</span><br><span class="line">		theRoot = towns[theRoot].parent;</span><br><span class="line">	<span class="keyword">while</span> (theTown != theRoot) &#123;</span><br><span class="line">		<span class="keyword">int</span> parentTown = towns[theTown].parent;</span><br><span class="line">		towns[theTown].parent = theRoot;</span><br><span class="line">		theTown = parentTown;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> theTown1, <span class="keyword">int</span> theTown2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (theTown1 == theTown2) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (towns[theTown1].parent &lt; towns[theTown2].parent) &#123;</span><br><span class="line">		towns[theTown2].parent += towns[theTown1].parent;</span><br><span class="line">		towns[theTown1].parent = theTown2;</span><br><span class="line">		towns[theTown1].root = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		towns[theTown1].parent += towns[theTown2].parent;</span><br><span class="line">		towns[theTown2].parent = theTown1;</span><br><span class="line">		towns[theTown2].root = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	N--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="keyword">while</span> (N) &#123;</span><br><span class="line">		initiaize();</span><br><span class="line">		<span class="keyword">int</span> M;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line">		<span class="keyword">while</span> (M--) &#123;</span><br><span class="line">			<span class="keyword">int</span> t1, t2;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">			<span class="keyword">int</span> root1 = find(t1);</span><br><span class="line">			<span class="keyword">int</span> root2 = find(t2);</span><br><span class="line"> 			unite(root1, root2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; N - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">delete</span>[]towns;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:用scanf读入速度更快。(大约是cin的$\dfrac {1}{4}$)</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/"><strong>最长连续序列</strong></a>:leetcode</p>
</li>
<li><p>参考题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting <span class="keyword">for</span> supplement......</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/"><strong>岛屿数量</strong></a>:leetcode</p>
</li>
<li><p>参考题解1:Oh首先想到的难道真的是UF吗……康康BFS</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> offset[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; land;</span><br><span class="line">                    land.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                    <span class="keyword">while</span> (!land.empty()) &#123;</span><br><span class="line">                        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; xy = land.front();</span><br><span class="line">                        land.pop();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; newXy;</span><br><span class="line">                            newXy.first = xy.first + offset[k][<span class="number">0</span>];</span><br><span class="line">                            newXy.second = xy.second + offset[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (newXy.first &gt;= <span class="number">0</span> &amp;&amp; newXy.first &lt; grid.size() &amp;&amp; newXy.second &gt;= <span class="number">0</span> &amp;&amp; newXy.second &lt; grid[i].size()) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (grid[newXy.first][newXy.second] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                                    land.push(newXy);</span><br><span class="line">                                    grid[newXy.first][newXy.second] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度:$$O(n^2).$$</p>
</li>
<li><p>哦那试试DFS?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.size() || y &lt; <span class="number">0</span> || y &gt;= grid[x].size() || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,x,y+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,x+<span class="number">1</span>,y);</span><br><span class="line">        dfs(grid,x,y<span class="number">-1</span>);</span><br><span class="line">        dfs(grid,x<span class="number">-1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.size();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[i].size();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                   dfs(grid,i,j);</span><br><span class="line">                   cnt++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度$$O(n^2).$$</p>
</li>
<li><p>并查集写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting <span class="keyword">for</span> supplement......</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="习题答案，P295，296"><a href="#习题答案，P295，296" class="headerlink" title="习题答案，P295，296"></a>习题答案，P295，296</h2><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><ul>
<li><p><input disabled="" type="checkbox">  优先级队列中的各个元素按照优先级(根据一定规则得到的重要程度)排列。</p>
</li>
<li><p>书上的基本实现</p>
</li>
<li><p>定制的异常类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXCEPTION_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXCEPTION_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">illegalOperation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	illegalOperation(<span class="keyword">const</span> <span class="built_in">string</span>&amp; errMsg = <span class="string">&quot;operation error!&quot;</span>) : error(errMsg) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> error;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>抽象类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAX_PRIORITY_QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PRIORITY_QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maxPriorityQueue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~maxPriorityQueue() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>大根堆(小根堆一样的方法)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAXHEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXHEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;maxPriorityQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exception.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @copyright: all rights reserved.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author: Joe-sdu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @date: Nov.18.2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maxHeap</span> :</span> <span class="keyword">public</span> maxPriorityQueue&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	maxHeap();</span><br><span class="line">	~maxHeap() &#123; <span class="keyword">delete</span>[]heap; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heapSize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heapSize; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(T* theHeap, <span class="keyword">int</span> theSize)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* heap;</span><br><span class="line">	<span class="keyword">int</span> heapSize;</span><br><span class="line">	<span class="keyword">int</span> arrLength;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">changeLength1D</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">maxHeap&lt;T&gt;::maxHeap() <span class="comment">// avoid dangling pointer</span></span><br><span class="line">&#123;</span><br><span class="line">	heap = <span class="keyword">new</span> T[<span class="number">1</span>];</span><br><span class="line">	heapSize = <span class="number">0</span>;</span><br><span class="line">	arrLength = <span class="number">1</span>; <span class="comment">// default 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> maxHeap&lt;T&gt;::changeLength1D()</span><br><span class="line">&#123;</span><br><span class="line">	T* temp = <span class="keyword">new</span> T[<span class="number">2</span> * arrLength];</span><br><span class="line">	copy(heap, heap + arrLength, temp);</span><br><span class="line">	arrLength *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">delete</span>[]heap;</span><br><span class="line">	heap = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> maxHeap&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (heapSize == <span class="number">0</span>) <span class="keyword">throw</span> illegalOperation(<span class="string">&quot;can&#x27;t pop from an empty tree!&quot;</span>);</span><br><span class="line">	heap[<span class="number">1</span>].~T();</span><br><span class="line">	T lastElement = heap[heapSize--];</span><br><span class="line">	<span class="keyword">int</span> currNode = <span class="number">1</span>, child = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt;= heapSize) &#123;</span><br><span class="line">		<span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>]) child++;</span><br><span class="line">		<span class="keyword">if</span> (lastElement &gt;= heap[child]) <span class="keyword">break</span>;</span><br><span class="line">		heap[currNode] = heap[child];</span><br><span class="line">		currNode = child;</span><br><span class="line">		child *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currNode] = lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; maxHeap&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (heapSize == <span class="number">0</span>) <span class="keyword">throw</span> illegalOperation(<span class="string">&quot;heap is empty!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> maxHeap&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (heapSize == arrLength - <span class="number">1</span>) changeLength1D();</span><br><span class="line">	<span class="keyword">int</span> currNode = ++heapSize;</span><br><span class="line">	<span class="keyword">while</span> (currNode != <span class="number">1</span> &amp;&amp; heap[currNode / <span class="number">2</span>] &lt; theElement) &#123;</span><br><span class="line">		heap[currNode] = heap[currNode / <span class="number">2</span>];</span><br><span class="line">		currNode /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currNode] = theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> maxHeap&lt;T&gt;::initialize(T* theHeap, <span class="keyword">int</span> theSize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]heap;</span><br><span class="line">	heap = theHeap;</span><br><span class="line">	heapSize = theSize;</span><br><span class="line">	arrLength = theSize + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> root = theSize / <span class="number">2</span>; root &gt;= <span class="number">1</span>; root--) &#123;</span><br><span class="line">		T rootElement = heap[root];</span><br><span class="line">		<span class="keyword">int</span> child = <span class="number">2</span> * root;</span><br><span class="line">		<span class="keyword">while</span> (child &lt;= heapSize) &#123;</span><br><span class="line">			<span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>]) child++;</span><br><span class="line">			<span class="keyword">if</span> (rootElement &gt;= heap[child]) <span class="keyword">break</span>;</span><br><span class="line">			heap[child / <span class="number">2</span>] = heap[child];</span><br><span class="line">			child *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		heap[child / <span class="number">2</span>] = rootElement;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>各方法时间复杂度:</p>
</li>
<li><p>empty、size和top均为$$\varTheta(1).$$</p>
</li>
<li><p>pop和push均为$$O(\log n).$$</p>
</li>
<li><p>initialize为$$O(n).$$</p>
</li>
<li><p>大根堆的各项操作的性质都挺好。</p>
</li>
<li><p><input disabled="" type="checkbox">  完善我们的大根堆</p>
</li>
<li><p>赋值构造函数和拷贝控制成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">maxHeap&lt;T&gt;::maxHeap(<span class="keyword">const</span> maxHeap&lt;T&gt;&amp; theHeap)</span><br><span class="line">&#123;</span><br><span class="line">	heapSize = theHeap.heap;</span><br><span class="line">	arrLength = theHeap.arrLength;</span><br><span class="line">	heap = <span class="keyword">new</span> T[arrLength];</span><br><span class="line">	copy(theHeap.heap, theHeap.heap + heapSize + <span class="number">2</span>, heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">maxHeap&lt;T&gt;&amp; maxHeap&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> maxHeap&lt;T&gt;&amp; theHeap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]heap;</span><br><span class="line">	heapSize = theHeap.heapSize;</span><br><span class="line">	arrLength = theHeap.arrLength;</span><br><span class="line">	heap = <span class="keyword">new</span> T[arrLength];</span><br><span class="line">	copy(theHeap.heap, theHeap.heap + heapSize + <span class="number">2</span>, heap);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="习题答案P305、306"><a href="#习题答案P305、306" class="headerlink" title="习题答案P305、306"></a>习题答案P305、306</h2></li>
<li><p><input disabled="" type="checkbox">  Page305、306，T6-9、11直接采用上面给出的类就可以解决。</p>
<blockquote>
<p>Tips: 要打印出6.2所说的树形很简单，循环控制格式就行。</p>
</blockquote>
</li>
<li><p><input disabled="" type="checkbox">  Page306，T12</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> maxHeap&lt;T&gt;::changeMax(<span class="keyword">const</span> T&amp; newElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (heapSize == <span class="number">0</span>) <span class="keyword">throw</span> illegalOperation(<span class="string">&quot;can&#x27;t carry out this operation on an empty tree!&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (newElement &gt;= heap[<span class="number">1</span>]) &#123;</span><br><span class="line">		heap[<span class="number">1</span>] = newElement;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[<span class="number">1</span>] = newElement;</span><br><span class="line">	<span class="keyword">int</span> currNode = <span class="number">1</span>, child = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt;= heapSize) &#123;</span><br><span class="line">		<span class="keyword">if</span> (child &lt; heapSize &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>]) child++;</span><br><span class="line">		<span class="keyword">if</span> (newElement &gt;= heap[child]) <span class="keyword">break</span>;</span><br><span class="line">		heap[currNode] = heap[child];</span><br><span class="line">		currNode = child;</span><br><span class="line">		child *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currNode] = newElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:记得加入公有声明changeMax。</p>
</blockquote>
</li>
<li><p><input disabled="" type="checkbox">  最大高度优先左高树</p>
</li>
<li><p>一棵树被称为高度优先左高树，当且仅当它每个节点左孩子的s值都不小于右孩子的s值。s值是从该节点到外部节点的最短路径。</p>
</li>
<li><p>书上给出的maxHblt的实现就很好了，我们直接给出再增补方法。</p>
</li>
<li><p>实现用到了队列，请自行参考队列章节文章。</p>
</li>
<li><p>书上的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><input disabled="" type="checkbox">  堆排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEAPSORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAPSORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;maxHeap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto heapSort(T* arr, int theSize) -&gt; T*</span><br><span class="line">&#123;</span><br><span class="line">	maxHeap&lt;T&gt; theHeap;</span><br><span class="line">	T* b = <span class="keyword">new</span> T[theSize + <span class="number">1</span>];</span><br><span class="line">	theHeap.initialize(arr, theSize);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = theSize; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		b[i] = theHeap.top();</span><br><span class="line">		theHeap.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度:$$O(n\log n)$$</p>
</li>
<li><p><input disabled="" type="checkbox">  机器调度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MACHINE_SCHEDULE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACHINE_SCHEDULE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;heapSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;minHeap.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jobNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> jobId, time;</span><br><span class="line">	jobNode(<span class="keyword">int</span> id = <span class="number">1</span>, <span class="keyword">int</span> initT = <span class="number">0</span>) : jobId(id), time(initT) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> time; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> jobNode&amp; job) &#123; <span class="keyword">return</span> time &gt;= job.time; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">machineNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> machineId, avail;</span><br><span class="line">	machineNode(<span class="keyword">int</span> id = <span class="number">1</span>, <span class="keyword">int</span> initT = <span class="number">0</span>) : machineId(id), avail(initT) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> machineNode&amp; machine) &#123; <span class="keyword">return</span> avail &lt;= machine.avail; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSchedule</span><span class="params">(jobNode jobs[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= m) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;shecdule each job to 1 machine!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	jobNode* jobTemp = heapSort(jobs, n);</span><br><span class="line">	minHeap&lt;machineNode&gt; mHeap;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) mHeap.push(machineNode(i, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		machineNode temp = mHeap.top();</span><br><span class="line">		mHeap.pop();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;schedule &quot;</span> &lt;&lt; jobTemp[i].jobId &lt;&lt; <span class="string">&quot;  to &quot;</span> &lt;&lt; temp.machineId &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		temp.avail += jobTemp[i].time;</span><br><span class="line">		mHeap.push(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:注意和书上实现的区别。minHeap自行实现(VS下用CF全局换，小于改大于，小于等于改大于等于即可)。</p>
</blockquote>
</li>
<li><p><input disabled="" type="checkbox">  霍夫曼编码</p>
</li>
</ul>
<h2 id="竞赛树"><a href="#竞赛树" class="headerlink" title="竞赛树"></a>竞赛树</h2><h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><h2 id="平衡搜索树"><a href="#平衡搜索树" class="headerlink" title="平衡搜索树"></a>平衡搜索树</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="分裂树"><a href="#分裂树" class="headerlink" title="分裂树"></a>分裂树</h2><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><h2 id="珂朵莉树"><a href="#珂朵莉树" class="headerlink" title="珂朵莉树"></a>珂朵莉树</h2><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><h2 id="析合树"><a href="#析合树" class="headerlink" title="析合树"></a>析合树</h2><h2 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h2><h2 id="朋友推荐的好听的歌"><a href="#朋友推荐的好听的歌" class="headerlink" title="朋友推荐的好听的歌!"></a>朋友推荐的好听的歌!</h2><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1396205229&auto=1&height=66"></iframe></div>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Joe-sdu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://joe-sdu.top/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/" title="树">http://joe-sdu.top/2020/11/12/数据结构习题答案/数据结构--树/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E5%89%8D%E8%A8%80/" rel="prev" title="关于数据结构与算法的一点约定">
      <i class="fa fa-chevron-left"></i> 关于数据结构与算法的一点约定
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%88/" rel="next" title="栈">
      栈 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%85%B6%E4%BB%96%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">二叉树和其他树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88%EF%BC%8CP280%E3%80%81281"><span class="nav-number">2.</span> <span class="nav-text">习题答案，P280、281</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88%EF%BC%8CP284%E3%80%81285"><span class="nav-number">3.</span> <span class="nav-text">习题答案，P284、285</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%94%BE%E5%A4%A7%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">信号放大器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E6%9F%90OJ%E4%B8%8A%E7%9A%84%E5%A5%87%E5%A6%99%E7%BB%8F%E5%8E%86"><span class="nav-number">5.</span> <span class="nav-text">并查集及其应用: 某OJ上的奇妙经历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88%EF%BC%8CP295%EF%BC%8C296"><span class="nav-number">6.</span> <span class="nav-text">习题答案，P295，296</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">优先级队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88P305%E3%80%81306"><span class="nav-number">8.</span> <span class="nav-text">习题答案P305、306</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E8%B5%9B%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">竞赛树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">10.</span> <span class="nav-text">搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">平衡搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">12.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E8%A3%82%E6%A0%91"><span class="nav-number">13.</span> <span class="nav-text">分裂树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">14.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">15.</span> <span class="nav-text">李超线段树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91"><span class="nav-number">16.</span> <span class="nav-text">珂朵莉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A0%91"><span class="nav-number">17.</span> <span class="nav-text">动态树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%90%E5%90%88%E6%A0%91"><span class="nav-number">18.</span> <span class="nav-text">析合树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%92%E5%88%86%E6%A0%91"><span class="nav-number">19.</span> <span class="nav-text">划分树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8B%E5%8F%8B%E6%8E%A8%E8%8D%90%E7%9A%84%E5%A5%BD%E5%90%AC%E7%9A%84%E6%AD%8C"><span class="nav-number">20.</span> <span class="nav-text">朋友推荐的好听的歌!</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Joe-sdu"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Joe-sdu</p>
  <div class="site-description" itemprop="description">Joe永远爱生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Joe-SDU?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Joe-SDU?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:joesdu@163.com" title="E-Mail → mailto:joesdu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joe-sdu</span>
</div>
<!--以下为添加的代码-->
      <!--统计start-->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="powered-by">
        <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
          本站访客数:<span id="busuanzi_value_site_uv"></span>
        </span>
        </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共14.1k字</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- 页面点击礼花效果 -->
<script type="text/javascript" src="/js/firework.js"></script>

</body>
</html>
