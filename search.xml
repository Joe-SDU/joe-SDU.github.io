<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2020/11/13/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<blockquote>
<p>我们终将被忘记。</p>
</blockquote>
]]></content>
      <categories>
        <category>记录生活</category>
      </categories>
  </entry>
  <entry>
    <title>关于数据结构与算法的一点约定</title>
    <url>/2020/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h2 id="代码约定"><a href="#代码约定" class="headerlink" title="代码约定"></a>代码约定</h2><ul>
<li><input disabled="" type="checkbox"> 代码块统一采用Times New Roman字体，点击右上角即可复制。</li>
<li><input disabled="" type="checkbox"> 代码在MSVC上编译通过，理论上只要环境相同copy下来就能跑。<a id="more"></a>
<blockquote>
<p>我的编译环境: </p>
</blockquote>
</li>
<li>IDE: Microsoft Visual Studio 2019</li>
<li>Target: x86_64-w64-mingw32</li>
<li>gcc: gcc version 8.1.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project)</li>
</ul>
<h2 id="答案约定"><a href="#答案约定" class="headerlink" title="答案约定"></a>答案约定</h2><ul>
<li><input disabled="" type="checkbox"> 有错的答案请私信回复我哈。</li>
</ul>
<h2 id="重复代码约定"><a href="#重复代码约定" class="headerlink" title="重复代码约定"></a>重复代码约定</h2><ul>
<li><input disabled="" type="checkbox"> 如果某代码在前面已经给出，后面不再赘述，只是简单提及。</li>
</ul>
<h2 id="题目顺序约定"><a href="#题目顺序约定" class="headerlink" title="题目顺序约定"></a>题目顺序约定</h2><ul>
<li><input disabled="" type="checkbox"> 题目不会按照第一题到最后一题的顺序给出，而是在比较自然的地方引入。题目前会标注题号。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法习题答案(机械工业出版社)</category>
      </categories>
  </entry>
  <entry>
    <title>HTML基础知识</title>
    <url>/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/HTML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="HTML基础篇"><a href="#HTML基础篇" class="headerlink" title="HTML基础篇"></a><strong>HTML基础篇</strong></h2><blockquote>
<p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p>
</blockquote>
<a id="more"></a>
<ul>
<li><input disabled="" type="checkbox"> HTML的基本框架<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是小徐的html页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p1</span>&gt;</span>这里是第一段<span class="tag">&lt;/<span class="name">p1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>注意:HTML中<xxx>代表一个标记，标记通常是成对存在的。</li>
<li><input disabled="" type="checkbox"> 如何开始编辑HTML</li>
</ul>
<p>1.直接采用记事本，具体操作很简单:鼠标停留在桌面–&gt;右键–&gt;建立文本文件–&gt;键入代码块–&gt;修改文件后缀为.html–&gt;保存文件–&gt;再次打开该文件。</p>
<blockquote>
<p>值得注意的是，默认解释html文件的浏览器是你电脑上设置的默认浏览器，windows用户默认浏览器可在设置里修改。</p>
</blockquote>
<p>2.使用VScode、sublime Text等文本编辑器进行html文件的编写。</p>
<ul>
<li><p><input disabled="" type="checkbox">  HTML中的保留字<br> 所谓保留字，就是一组html语法规范里出现的关键字或者符号，包括&lt;和&gt;等等，浏览器在遇到这些符号时会不清楚到底是一个标签还是小于号/大于号。我们可以用实体数字来解决此问题。常见的实体数字如下:</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>实体名称(不推荐)</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>&amp;it</td>
<td>&amp;#60</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt</td>
<td>&amp;#62</td>
</tr>
<tr>
<td>空格</td>
<td>&amp;nbsp</td>
<td>&amp;#160</td>
</tr>
</tbody></table>
</li>
<li><p><input disabled="" type="checkbox">  HTML标题<br>HTML标题，也称heading，是通过h1到h6六个标签定义的，标题会被默认显示成大字、粗体。我们给出实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是第二个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><input disabled="" type="checkbox">  HTML段落<br>HTML段落，也称paragraph，是通过p标签定义的。我们给出实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:默认情况下浏览器会在标题前后增加默认空行，会在块级元素后增加一个空行。<br>标题不可做他用，搜索引擎用标题为网页的结构和内容编制索引。<br>网页标题从h1到h6优先级递减。</p>
</blockquote>
</li>
<li><p><input disabled="" type="checkbox">  HTML水平线<br>HTML水平线，用来在界面中分割内容，用hr表示，我们给出实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">hr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>第二部分<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><input disabled="" type="checkbox">  HTML注释<br>注释是给编写代码的人看的，不会影响网页结构，格式如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是注释 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><input disabled="" type="checkbox">  HTML链接<br>HTML链接，也称link，是通过a标签定义的。我们给出实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;joe-sdu.top&quot;</span>&gt;</span>顺着网线就能找到小徐!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其中href后面跟着的是链接地址，两个标签里的话是网页显示的文字，点击这句话就能跳转。</p>
</li>
<li><p><input disabled="" type="checkbox">  HTML图像<br>HTML图像，是通过img标签定义的。我们给出实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:/Users/images/小徐的照片屋&quot;</span> <span class="attr">width</span> = <span class="string">&quot;100&quot;</span> <span class="attr">height</span> = <span class="string">&quot;200&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>这个例子似乎有点特殊，原因在于，它没有成对的标签，而是在一个标签里加入了/，同时它引入了几个属性，src:也称source，代表存放图片的路径，width:希望展示图片的宽度，height:希望展示图片的高度。</p>
</li>
<li><p><input disabled="" type="checkbox">  HTML元素<br>HTML元素，指的是在开始标记和结束标记之间的内容(也就是上面所说的一对标签之内的内容)。HTML元素语法如下:</p>
</li>
<li><p>HTML元素以开始标记为起始。</p>
</li>
<li><p>HTML元素以结束标记为结束。</p>
</li>
<li><p>HTML元素内容是位于开始和结束标签之间的内容。</p>
</li>
<li><p>HTML某些元素具有空内容。</p>
</li>
<li><p>HTML空元素在开始标记中就结束。</p>
</li>
<li><p>HTML大多数元素可以拥有属性，比如上面的img。</p>
</li>
<li><p>HTML元素可以嵌套，简而言之就是一个元素中可以包含其他元素。<br>我们针对一些特殊的HTML元素进行解释:</p>
</li>
<li><p>HTML中的html元素，它定义了整个html文档。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	这里是其他元素内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTML中的body元素，它定义了文档的主体。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	这里是其他元素内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTML中的空元素，以换行为例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips:html中的标签最好采用小写，即使html对大小写并不敏感。</p>
</blockquote>
</li>
<li><p><input disabled="" type="checkbox">  HTML属性</p>
</li>
<li><p>HTML中的属性总是以键值对的形式出现，且在开始标签中规定，属性值总是要打引号，属性采用小写(尽管html不区分大小写)。我们给出一些针对性属性及其含义:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>定义的标签</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>链接</td>
<td>a</td>
<td>href</td>
</tr>
<tr>
<td>居中排列标题</td>
<td>h</td>
<td>align</td>
</tr>
<tr>
<td>背景颜色</td>
<td>body</td>
<td>bgcolor</td>
</tr>
<tr>
<td>表格边框</td>
<td>table</td>
<td>boder</td>
</tr>
</tbody></table>
</li>
<li><p>下面是一些适用于大多数HTML元素的属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>规定元素的内容</td>
<td>class</td>
</tr>
<tr>
<td>规定元素唯一的id</td>
<td>id</td>
</tr>
<tr>
<td>规定元素的行内样式</td>
<td>style</td>
</tr>
<tr>
<td>规定元素额外的信息</td>
<td>title</td>
</tr>
</tbody></table>
<p><a href="https://www.w3schools.com/html/">更多具体属性可点击查看</a></p>
</li>
<li><p><input disabled="" type="checkbox">  HTML样式<br>HTML样式通过style属性来设置，在以前，有些样式可以通过一些标签和属性来实现。然而在HTML的发展过程中，有些标签和属性逐渐被淘汰，我们应该尽量避免使用，它们是:</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>center</td>
<td>定义居中的内容</td>
</tr>
<tr>
<td>font/basefont</td>
<td>定义字体</td>
</tr>
<tr>
<td>s/strike</td>
<td>定义删除线文本</td>
</tr>
<tr>
<td>u</td>
<td>定义下划线文本</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>align</td>
<td>定义文字对齐方式</td>
</tr>
<tr>
<td>bgcolor</td>
<td>定义背景颜色</td>
</tr>
<tr>
<td>color</td>
<td>定义文本颜色</td>
</tr>
</tbody></table>
</li>
<li><p>我们用对应的样式代替上面的标签和属性:</p>
</li>
</ul>
<p>1.用background-color样式代替bgcolor:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span> = <span class="string">&quot;background-color:green&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这是绿色的主体 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span> = <span class="string">&quot;background-color:red&quot;</span>&gt;</span>这是红色的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">&quot;background-color:blue&quot;</span>&gt;</span>这是蓝色的段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML进阶篇"><a href="#HTML进阶篇" class="headerlink" title="HTML进阶篇"></a>HTML进阶篇</h2><p><strong>小徐还没来得及写哦~</strong></p>
<h2 id="很适合学习的时候听的歌呀"><a href="#很适合学习的时候听的歌呀" class="headerlink" title="很适合学习的时候听的歌呀!"></a>很适合学习的时候听的歌呀!</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=35847042&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>搭建一个小型博客需要的前导知识</category>
      </categories>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%88/</url>
    <content><![CDATA[<p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p>
<a id="more"></a>
<h2 id="栈在教材上的应用"><a href="#栈在教材上的应用" class="headerlink" title="栈在教材上的应用"></a>栈在教材上的应用</h2><blockquote>
<p>栈是一种十分有用的数据结构!!在后续学习中会不断出现对它的应用!!请大家务必掌握!!</p>
</blockquote>
<ul>
<li>栈的纯虚基类<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纯虚基类</span></span><br><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H_</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">stack</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>数组实现的栈<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组实现的栈</span></span><br><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pureBaseStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayStack</span> :</span> <span class="keyword">public</span> <span class="built_in">stack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~arrayStack() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line">	arrayStack(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> stackTop == <span class="number">-1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> stackTop + <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* element;</span><br><span class="line">	<span class="keyword">int</span> stackTop;</span><br><span class="line">	<span class="keyword">int</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">arrayStack&lt;T&gt;::arrayStack(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;can&#x27;t creat a stack with capacity &lt;= 0!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">	element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">	stackTop = <span class="number">-1</span>;</span><br><span class="line">	arrayLength = initialCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; arrayStack&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackTop == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> element[stackTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayStack&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackTop == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;can&#x27;t pop from an empty stack!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">	element[stackTop--].~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayStack&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackTop == arrayLength - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arrayLength *= <span class="number">2</span>;</span><br><span class="line">		T* temp = <span class="keyword">new</span> T[arrayLength];</span><br><span class="line">		<span class="built_in">std</span>::copy(element, element + stackTop + <span class="number">1</span>, temp);</span><br><span class="line">		<span class="keyword">delete</span>[]element;</span><br><span class="line">		element = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	element[++stackTop] = theElement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>链表实现的栈<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pureBaseStack.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T element;</span><br><span class="line">	stackNode* next;</span><br><span class="line">	stackNode() = <span class="keyword">default</span>;</span><br><span class="line">	stackNode(<span class="keyword">const</span> T&amp; theElement) : element(theElement) &#123;&#125;</span><br><span class="line">	stackNode(<span class="keyword">const</span> T&amp; theElement, stackNode&lt;T&gt;* theNext) : element(theElement), next(theNext) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedStack</span> :</span> <span class="keyword">public</span> <span class="built_in">stack</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~linkedStack();</span><br><span class="line">	linkedStack(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> stackSize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>&#123; <span class="keyword">return</span> stackSize; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	stackNode&lt;T&gt;* stackTop;</span><br><span class="line">	<span class="keyword">int</span> stackSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedStack&lt;T&gt;::~linkedStack()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (stackTop != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		stackNode&lt;T&gt;* nextNode = stackTop-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> stackTop;</span><br><span class="line">		stackTop = nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedStack&lt;T&gt;::linkedStack(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;can&#x27;t creat a stack with capacity &lt;= 0!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">	stackSize = <span class="number">0</span>;</span><br><span class="line">	stackTop = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; linkedStack&lt;T&gt;::top() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackSize == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;Stack is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stackTop-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedStack&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackSize == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;can&#x27;t pop from an empty stack!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">	stackNode&lt;T&gt;* nextNode = stackTop-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> stackTop;</span><br><span class="line">	stackTop = nextNode;</span><br><span class="line">	stackSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedStack&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	stackTop = <span class="keyword">new</span> stackNode&lt;T&gt;(theElement, stackTop);</span><br><span class="line">	stackSize++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>双栈共享空间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created on 2020.10.21 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TWOSTACKS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOSTACKS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">twoStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~twoStack() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line">	twoStack(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> stackTop1 == <span class="number">-1</span> &amp;&amp; stackTop2 == arrayLength; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> stackTop1 - stackTop2 + arrayLength + <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">top</span><span class="params">(<span class="keyword">int</span> stackNumber)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNumber)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNumber, <span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* element;</span><br><span class="line">	<span class="keyword">int</span> stackTop1;</span><br><span class="line">	<span class="keyword">int</span> stackTop2;</span><br><span class="line">	<span class="keyword">int</span> arrayLength;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> stackNumber)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> twoStack&lt;T&gt;::check(<span class="keyword">int</span> stackNumber) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackNumber &lt; <span class="number">1</span> || stackNumber &gt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;stackNumber input error!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span> s.str();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">twoStack&lt;T&gt;::twoStack(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">	element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">	arrayLength = initialCapacity;</span><br><span class="line">	stackTop1 = <span class="number">-1</span>;</span><br><span class="line">	stackTop2 = arrayLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; twoStack&lt;T&gt;::top(<span class="keyword">int</span> stackNumber) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	check(stackNumber);</span><br><span class="line">	<span class="keyword">switch</span> (stackNumber)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">if</span> (stackTop1 == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">			s &lt;&lt; <span class="string">&quot;stack1 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">throw</span> s.str();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> element[stackTop1];</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">if</span> (stackTop2 == arrayLength)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">			s &lt;&lt; <span class="string">&quot;stack2 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">throw</span> s.str();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> element[stackTop2];</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> twoStack&lt;T&gt;::pop(<span class="keyword">int</span> stackNumber)</span><br><span class="line">&#123;</span><br><span class="line">	check(stackNumber);</span><br><span class="line">	<span class="keyword">switch</span> (stackNumber)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">if</span> (stackTop1 == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">			s &lt;&lt; <span class="string">&quot;stack1 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">throw</span> s.str();</span><br><span class="line">		&#125;</span><br><span class="line">		element[stackTop1--].~T();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">if</span> (stackTop2 == arrayLength)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">			s &lt;&lt; <span class="string">&quot;stack2 is empty!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">throw</span> s.str();</span><br><span class="line">		&#125;</span><br><span class="line">		element[stackTop2++].~T();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> twoStack&lt;T&gt;::push(<span class="keyword">int</span> stackNumber, <span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	check(stackNumber);</span><br><span class="line">	<span class="keyword">if</span> (stackTop1 + <span class="number">1</span> == stackTop2)</span><br><span class="line">	&#123;</span><br><span class="line">		T* temp = <span class="keyword">new</span> T[<span class="number">2</span> * arrayLength];</span><br><span class="line">		<span class="built_in">std</span>::copy(element, element + stackTop1 + <span class="number">1</span>, temp);</span><br><span class="line">		<span class="built_in">std</span>::copy(element + stackTop2, element + arrayLength, temp + arrayLength + stackTop2);</span><br><span class="line">		<span class="keyword">delete</span>[]element;</span><br><span class="line">		element = temp;</span><br><span class="line">		stackTop2 = arrayLength + stackTop2;</span><br><span class="line">		arrayLength *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (stackNumber)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		element[++stackTop1] = theElement;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		element[--stackTop2] = theElement;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>括号匹配<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// complexity of time:O(s.size())</span></span><br><span class="line"><span class="comment">// extra complexity of space:O(s.size())</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchWithStack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	arrayStack&lt;<span class="keyword">char</span>&gt; matchStack;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			matchStack.push(s[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = matchStack.top();</span><br><span class="line">			<span class="keyword">if</span> (temp == s[i])</span><br><span class="line">				matchStack.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!matchStack.empty())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>列车重排<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列车重排</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">arrayStack&lt;<span class="keyword">int</span>&gt;* rails;</span><br><span class="line"><span class="keyword">int</span> numberOfCars;</span><br><span class="line"><span class="keyword">int</span> numberOfTrails;</span><br><span class="line"><span class="keyword">int</span> smallestCar;</span><br><span class="line"><span class="keyword">int</span> itsTrail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputCarFromTrail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rails[itsTrail].pop();</span><br><span class="line">	smallestCar = numberOfCars + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfTrails; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rails[i].empty() &amp;&amp; rails[i].top() &lt; smallestCar)</span><br><span class="line">		&#123;</span><br><span class="line">			smallestCar = rails[i].top();</span><br><span class="line">			itsTrail = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inputCarToTrail</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bestTrail = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> bestTop = numberOfCars + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfTrails; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rails[i].empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = rails[i].top();</span><br><span class="line">			<span class="keyword">if</span> (n &lt; d &amp;&amp; d &lt; bestTop)</span><br><span class="line">			&#123;</span><br><span class="line">				bestTop = d;</span><br><span class="line">				bestTrail = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			bestTrail = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bestTrail == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	rails[bestTrail].push(n);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; smallestCar)</span><br><span class="line">	&#123;</span><br><span class="line">		smallestCar = n;</span><br><span class="line">		itsTrail = bestTrail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">railRoad</span><span class="params">(<span class="keyword">int</span> input[], <span class="keyword">int</span> theNumberOfCars, <span class="keyword">int</span> theNumberOfTrails)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	numberOfCars = theNumberOfCars;</span><br><span class="line">	numberOfTrails = theNumberOfTrails;</span><br><span class="line">	rails = <span class="keyword">new</span> arrayStack&lt;<span class="keyword">int</span>&gt;[theNumberOfTrails + <span class="number">1</span>];</span><br><span class="line">	smallestCar = numberOfCars + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nextCarToOutput = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfCars; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (input[i] == nextCarToOutput)</span><br><span class="line">		&#123;</span><br><span class="line">			nextCarToOutput++;</span><br><span class="line">			<span class="keyword">while</span> (smallestCar == nextCarToOutput)</span><br><span class="line">			&#123;</span><br><span class="line">				outputCarFromTrail();</span><br><span class="line">				nextCarToOutput++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (!inputCarToTrail(input[i]))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>离线等价类<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 离线等价类</span></span><br><span class="line"><span class="comment">// offline equiralence classes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">offlineEquiralenceClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;can&#x27;t calculate set with elements &lt; 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;can&#x27;t calculate set with relations &lt; 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arrayStack&lt;<span class="keyword">int</span>&gt;* <span class="built_in">list</span> = <span class="keyword">new</span> arrayStack&lt;<span class="keyword">int</span>&gt;[n + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">list</span>[a].push(b);</span><br><span class="line">		<span class="built_in">list</span>[b].push(a);</span><br><span class="line">	&#125;</span><br><span class="line">	arrayStack&lt;<span class="keyword">int</span>&gt; unprocessedList;</span><br><span class="line">	<span class="keyword">bool</span> *out = <span class="keyword">new</span> <span class="keyword">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		out[i] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> tol = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!out[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;class &quot;</span> &lt;&lt; tol &lt;&lt; <span class="string">&quot; is:&quot;</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">			out[i] = <span class="literal">true</span>;</span><br><span class="line">			unprocessedList.push(i);</span><br><span class="line">			<span class="keyword">while</span> (!unprocessedList.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> j = unprocessedList.top();</span><br><span class="line">				unprocessedList.pop();</span><br><span class="line">				<span class="keyword">while</span> (!<span class="built_in">list</span>[j].empty())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> q = <span class="built_in">list</span>[j].top();</span><br><span class="line">					<span class="built_in">list</span>[j].pop();</span><br><span class="line">					<span class="keyword">if</span> (!out[q])</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">						out[q] = <span class="literal">true</span>;</span><br><span class="line">						unprocessedList.push(q);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			tol++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>汉诺塔<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 汉诺塔</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">arrayStack&lt;<span class="keyword">int</span>&gt; Hanoi[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveAndShow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		moveAndShow(n - <span class="number">1</span>, x, z, y);</span><br><span class="line">		<span class="keyword">int</span> d = Hanoi[x].top();</span><br><span class="line">		Hanoi[x].pop();</span><br><span class="line">		Hanoi[y].push(d);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;从&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;移动[&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;到&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		moveAndShow(n - <span class="number">1</span>, z, y, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HanoiTower</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		Hanoi[<span class="number">1</span>].push(i);</span><br><span class="line">	moveAndShow(n, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迷宫老鼠<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迷宫老鼠</span></span><br><span class="line"><span class="comment">// find path in a maze</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> maze[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> row, col;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入迷宫尺寸:&quot;</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maze[<span class="number">0</span>][i] = maze[size + <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">		maze[i][<span class="number">0</span>] = maze[i][size + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arrayStack&lt;position&gt;* path = <span class="keyword">new</span> arrayStack&lt;position&gt;;</span><br><span class="line">	<span class="keyword">int</span> barrRow, barrCol;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入障碍数量:&quot;</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; barrRow &gt;&gt; barrCol;</span><br><span class="line">		<span class="keyword">while</span>(barrRow &lt; <span class="number">1</span> || barrCol &lt; <span class="number">1</span> || barrRow &gt; size || barrCol &gt; size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入的障碍物有误，请输入正确的障碍物坐标:&quot;</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; barrRow &gt;&gt; barrCol;</span><br><span class="line">		&#125;</span><br><span class="line">		maze[barrRow][barrCol] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	position end;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入终点位置:&quot;</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; end.row &gt;&gt; end.col;</span><br><span class="line">	<span class="keyword">while</span> (end.row &lt; <span class="number">0</span> || end.col &lt; <span class="number">0</span> || end.row &gt; size + <span class="number">1</span> || end.col &gt; size + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;终点位置不符合规范，请重新输入:&quot;</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; end.row &gt;&gt; end.col;</span><br><span class="line">	&#125;</span><br><span class="line">	position offset[<span class="number">4</span>];</span><br><span class="line">	offset[<span class="number">0</span>].row = <span class="number">0</span>; offset[<span class="number">0</span>].col = <span class="number">1</span>;</span><br><span class="line">	offset[<span class="number">1</span>].row = <span class="number">1</span>; offset[<span class="number">1</span>].col = <span class="number">0</span>;</span><br><span class="line">	offset[<span class="number">2</span>].row = <span class="number">0</span>; offset[<span class="number">2</span>].col = <span class="number">-1</span>;</span><br><span class="line">	offset[<span class="number">3</span>].row = <span class="number">-1</span>; offset[<span class="number">3</span>].col = <span class="number">0</span>;</span><br><span class="line">	position here;</span><br><span class="line">	here.row = <span class="number">1</span>; here.col = <span class="number">1</span>;</span><br><span class="line">	maze[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> option = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lastOption = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (here.row != end.row || here.col != end.col)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> r, c;</span><br><span class="line">		<span class="keyword">while</span> (option &lt;= lastOption)</span><br><span class="line">		&#123;</span><br><span class="line">			r = here.row + offset[option].row;</span><br><span class="line">			c = here.col + offset[option].col;</span><br><span class="line">			<span class="keyword">if</span> (maze[r][c] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			option++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (option &lt;= lastOption)</span><br><span class="line">		&#123;</span><br><span class="line">			path-&gt;push(here);</span><br><span class="line">			here.row = r;</span><br><span class="line">			here.col = c;</span><br><span class="line">			maze[r][c] = <span class="number">1</span>;</span><br><span class="line">			option = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (path-&gt;empty())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			position next = path-&gt;top();</span><br><span class="line">			path-&gt;pop();</span><br><span class="line">			<span class="keyword">if</span> (next.row == here.row)</span><br><span class="line">				option = <span class="number">2</span> + next.col - here.col;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				option = <span class="number">3</span> + (next.row - here.row) % <span class="number">4</span>;</span><br><span class="line">			here = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!path-&gt;empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; path-&gt;top().row &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; path-&gt;top().col &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		path-&gt;pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>开关盒布线<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开关盒布线</span></span><br><span class="line"><span class="comment">// check net and judge</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linkedStack.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBox</span><span class="params">(<span class="keyword">int</span> net[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	linkedStack&lt;<span class="keyword">int</span>&gt;* s = <span class="keyword">new</span> linkedStack&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!s-&gt;empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (net[i] == net[s-&gt;top()])</span><br><span class="line">				s-&gt;pop();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				s-&gt;push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			s-&gt;push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!s-&gt;empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;box is not routable!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;box is routable!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的习题"><a href="#栈的习题" class="headerlink" title="栈的习题"></a>栈的习题</h2>小徐太懒了还没开始写~</li>
</ul>
<h2 id="前中后缀表达式-学习让计算机处理算术表达式"><a href="#前中后缀表达式-学习让计算机处理算术表达式" class="headerlink" title="前中后缀表达式: 学习让计算机处理算术表达式"></a>前中后缀表达式: 学习让计算机处理算术表达式</h2><ul>
<li><p><input disabled="" type="checkbox">  了解前中后缀表达式</p>
</li>
<li><p><input disabled="" type="checkbox">  中缀表达式<br>中缀表达式是最贴近我们人的阅读习惯的一类表达式，它和我们平常生活中接触到的数学算式没有区别，它的出现完全是方便人类进行数学演算，然而这种表达式对计算机而言是生涩难懂的。</p>
</li>
<li><p>中缀表达式形如: $3\times 2+(4-2)\times 7 -8\div (6+3)$</p>
</li>
<li><p><input disabled="" type="checkbox">  前缀表达式<br>顾名思义，前缀表达式是运算符在它的(注意这个”它的”的含义)操作数之前的表达式，计算机很容易就能在线性时间内完成对前缀表达式的计算。</p>
</li>
<li><p>前缀表达式形如: $-+1\times +2\ 3\ 4\ 5$</p>
</li>
<li><p>中缀表达式转前缀表达式的规则:</p>
</li>
</ul>
<p>1.维护两个栈，一个栈叫做s1，另一个栈叫做s2，s2用来保存中间结果。<br>2.从右至左扫描中缀表达式:</p>
<ul>
<li><p>若遇到数字，直接压入栈s1.</p>
</li>
<li><p>若遇到运算符，则分以下情况:<br>  1.s2为空或者栈顶运算符为’)’，则直接将其压入s2。</p>
<p>  2.s2中栈顶运算符优先级不高于($\leq$)此运算符，也将该运算符压入s2。 </p>
<p>  3.s2中栈顶元素优先级高于该运算符，则持续将s2栈顶的元素弹入s1，直到某一刻s2栈顶的元素满足如上1，2两个条件之一，则将该运算符压入s2(在此之前这个运算符一直在等待着被插入)。</p>
</li>
</ul>
<p>3.遇到括号时:</p>
<ul>
<li>如果是’)’，则直接压入s2。</li>
<li>如果是’(‘，则持续将s2的栈顶元素弹入s1，直到遇到’)’，然后将s2顶部的’)’弹出。</li>
</ul>
<p>4.扫描结束时，把s2中剩余运算符全部弹入s1。<br>5.把s1中元素全部弹出。</p>
<ul>
<li>计算前缀表达式</li>
</ul>
<p>1.同样维护一个栈，名叫s1。</p>
<p>2.从右至左扫描前缀表达式，遇到数字，则进栈，遇到运算符，则取出栈顶的两个元素，按照先后顺序称为$x_1$和$x_2$，计算$x_1$ $(+\ -\ \times \ \div)$ $x_2$，把结果入栈。</p>
<p>3.扫描结束时，s1中剩余元素即是结果。</p>
<blockquote>
<p>Tips:为什么在比较操作符优先级时，栈顶运算的优先级不高于正在操作的运算符时才压入栈呢?想象一下，当有两个同样优先级的运算符出现在中缀表达式中时，举个例子，$+和-$，假设$+$在左，$-$<br>在右，由于我们是从右向左扫描，$-$必然会在$+$之前进入s2，此时，如若在碰到$+$后，直接将$-$弹入s1，那么在最终得到的前缀表达式中，$-$必然在$+$之后出现，然而计算时扫描是从右往左，这意味着<br>最终计算时$-$先被拿来计算了，这显然不正确。</p>
</blockquote>
<ul>
<li><p>举例(自行模拟):</p>
</li>
<li><p>中缀表达式: $$1+((2+3)\times 4)-5$$</p>
</li>
<li><p>其前缀表达式为$$-+1\times+2\ 3\ 4\ 5$$</p>
</li>
<li><p>计算的过程:<br>$$将5，4，3，2均入栈$$<br>$$取2和3，执行2+3，把5入栈$$<br>$$取5和4，执行5\times 4，把20入栈$$<br>$$……$$<br>$$得到结果为16.$$</p>
</li>
<li><p><input disabled="" type="checkbox">  后缀表达式<br>后缀表达式和前缀表达式十分类似，但在细节处有所不同。后缀表达式是运算符都在它的操作数之后的表达式。</p>
</li>
<li><p>后缀表达式形如: $1\ 2\ 3 + 4\times+5-$</p>
</li>
<li><p>中缀表达式转后缀表达式的规则:</p>
</li>
</ul>
<p>1.维护两个栈，一个栈叫做s1，另一个栈叫做s2，s2用来保存中间结果。<br>2.从左至右扫描中缀表达式:</p>
<ul>
<li><p>若遇到数字，直接压入栈s1.</p>
</li>
<li><p>若遇到运算符，则分以下情况:<br>  1.s2为空或者栈顶运算符为’(‘，则直接将其压入s2。</p>
<p>  2.s2中栈顶运算符优先级低于(细节!!)此运算符，也将该运算符压入s2。 </p>
<p>  3.s2中栈顶元素优先级不低于($\geq$)该运算符，则持续将s2栈顶的元素弹入s1，直到某一刻s2栈顶的元素满足如上1，2两个条件之一，则将该运算符压入s2(在此之前这个运算符一直在等待着被插入)。</p>
</li>
</ul>
<p>3.遇到括号时:</p>
<ul>
<li>如果是’(‘，则直接压入s2。</li>
<li>如果是’)’，则持续将s2的栈顶元素弹入s1，直到遇到’(‘，然后将s2顶部的’(‘弹出。</li>
</ul>
<p>4.扫描结束时，把s2中剩余运算符全部弹入s1。<br>5.把s1中元素全部弹出。</p>
<ul>
<li>计算后缀表达式</li>
</ul>
<p>1.同样维护一个栈，名叫s1。</p>
<p>2.从左至右扫描后缀表达式，遇到数字，则进栈，遇到运算符，则取出栈顶的两个元素，按照先后顺序称为$x_1$和$x_2$，计算$x_2$ $(+\ -\ \times \ \div)$ $x_1$(细节!!)，把结果入栈。</p>
<p>3.扫描结束时，s1中剩余元素即是结果。</p>
<ul>
<li><p>例子不表</p>
</li>
<li><p><input disabled="" type="checkbox">  给定中缀表达式求运算结果的C++实现: 仅给出中缀转前缀实现，该实现仅能计算10以内的整数的中缀表达式，扩展可以自行实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrayStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> expr;</span><br><span class="line">	arrayStack&lt;<span class="keyword">char</span>&gt; s1, s2;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; expr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = expr.length()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// Scan from right to left</span></span><br><span class="line">		<span class="keyword">char</span> e = expr.at(i);</span><br><span class="line">		<span class="keyword">if</span> (e &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; e &lt;= <span class="string">&#x27;9&#x27;</span>) s1.push(e);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="string">&#x27;)&#x27;</span>) s2.push(e);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">				<span class="keyword">char</span> t = s2.top();</span><br><span class="line">				s2.pop();</span><br><span class="line">				<span class="keyword">if</span> (t == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">				s1.push(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (s2.empty()) &#123; s2.push(e); <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">char</span> t = s2.top();</span><br><span class="line">			<span class="keyword">if</span> (t == <span class="string">&#x27;)&#x27;</span>) s2.push(e);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="string">&#x27;*&#x27;</span> || e == <span class="string">&#x27;/&#x27;</span>) s2.push(e);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">					t = s2.top();</span><br><span class="line">					<span class="keyword">if</span> (t == <span class="string">&#x27;+&#x27;</span> || t == <span class="string">&#x27;-&#x27;</span> || t == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">						s2.push(e);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					s1.push(t);</span><br><span class="line">					s2.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (s2.empty()) s2.push(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s2.empty()) &#123; <span class="comment">// Clear remaining</span></span><br><span class="line">		<span class="keyword">char</span> t = s2.top();</span><br><span class="line">		s2.pop();</span><br><span class="line">		s1.push(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s1.empty()) &#123; <span class="comment">// Output</span></span><br><span class="line">		<span class="keyword">char</span> t = s1.top();</span><br><span class="line">		s1.pop();</span><br><span class="line">		s2.push(t);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// To use double, we open another Stack</span></span><br><span class="line">	arrayStack&lt;<span class="keyword">double</span>&gt; s3;</span><br><span class="line">	<span class="keyword">while</span> (!s2.empty()) &#123; <span class="comment">// Scan from right to left</span></span><br><span class="line">		<span class="keyword">char</span> e = s2.top();</span><br><span class="line">		s2.pop();</span><br><span class="line">		<span class="keyword">if</span> (e &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; e &lt;= <span class="string">&#x27;9&#x27;</span>) s3.push(<span class="keyword">double</span>(e-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">			<span class="keyword">double</span> left = s3.top();</span><br><span class="line">			s3.pop();</span><br><span class="line">			<span class="keyword">double</span> right = s3.top();</span><br><span class="line">			s3.pop();</span><br><span class="line">			<span class="keyword">switch</span> (e) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: &#123;result = left + right; <span class="keyword">break</span>; &#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: &#123;result = left - right; <span class="keyword">break</span>; &#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: &#123;result = left * right; <span class="keyword">break</span>; &#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: &#123;result = left / right; <span class="keyword">break</span>; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			s3.push(result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; s3.top();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度:$$O(n)，表达式中每个元素最多进栈和出栈常数次。$$</p>
</li>
</ul>
<p><strong>实际上，前缀表达式称为波兰式，后缀表达式称为逆波兰式。</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 人工求前后缀表达式的简易方法:</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法习题答案(机械工业出版社)</category>
      </categories>
  </entry>
  <entry>
    <title>跳表和散列</title>
    <url>/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E8%B7%B3%E8%A1%A8%E5%92%8C%E6%95%A3%E5%88%97/</url>
    <content><![CDATA[<p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p>
<a id="more"></a>
<h2 id="字典在教材上实现"><a href="#字典在教材上实现" class="headerlink" title="字典在教材上实现"></a>字典在教材上实现</h2><ul>
<li>纯虚基类<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DICTIONARY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICTIONARY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">pair</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dictionary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~dictionary() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	virtual pair&lt;const K, E&gt;* find(const K&amp; theKey) const = 0;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt;&amp; thePair)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp; theKey)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>头节点<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAIRNODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAIRNODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pairNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt; element;</span><br><span class="line">	pairNode&lt;K, E&gt;* next;</span><br><span class="line">	pairNode() &#123;&#125;</span><br><span class="line">	pairNode(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt;&amp; thePair) : element(thePair) &#123;&#125;</span><br><span class="line">	pairNode(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt;&amp; thePair, pairNode&lt;K, E&gt;* theNext)</span><br><span class="line">		: element(thePair), next(theNext) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>链式实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORTEDCHAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTEDCHAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dictionary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pairNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @copyright: all rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @author: Joe-sdu.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @date: Nov.21.2020</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sortedChain</span> :</span> <span class="keyword">public</span> dictionary&lt;K, E&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	sortedChain();</span><br><span class="line">	~sortedChain();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> dictSize == <span class="number">0</span>; &#125; <span class="comment">// C++11</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> dictSize; &#125; <span class="comment">// C++11</span></span><br><span class="line">	pair&lt;const K, E&gt;* find(const K&amp; theKey) const;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt;&amp; thePair)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> K&amp; theKey)</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Explanation:</span></span><br><span class="line"><span class="comment">		1. find return nullptr when we can&#x27;t find the element.</span></span><br><span class="line"><span class="comment">		2. erase do nothing when we can&#x27;t find the element.</span></span><br><span class="line"><span class="comment">		find、insert and erase cost: O(dictSize).</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pairNode&lt;K, E&gt;* firstNode;</span><br><span class="line">	<span class="keyword">int</span> dictSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line">sortedChain&lt;K, E&gt;::sortedChain()</span><br><span class="line">&#123;</span><br><span class="line">	firstNode = <span class="literal">nullptr</span>;</span><br><span class="line">	dictSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line">sortedChain&lt;K, E&gt;::~sortedChain()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (firstNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pairNode&lt;K, E&gt;* nextNode = firstNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> firstNode;</span><br><span class="line">		firstNode = nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt;* sortedChain&lt;K, E&gt;::find(<span class="keyword">const</span> K&amp; theKey)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	pairNode&lt;K, E&gt;* currNode = firstNode;</span><br><span class="line">	<span class="keyword">while</span> (currNode != <span class="literal">nullptr</span> &amp;&amp; currNode-&gt;element.first &lt; theKey) &#123;</span><br><span class="line">		currNode = currNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currNode != <span class="literal">nullptr</span> &amp;&amp; currNode-&gt;element.first == theKey) <span class="keyword">return</span> &amp;currNode-&gt;element;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> sortedChain&lt;K, E&gt;::insert(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">const</span> K, E&gt;&amp; thePair)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		three situations:</span></span><br><span class="line"><span class="comment">		1. no element.</span></span><br><span class="line"><span class="comment">		2. insert in the middle.</span></span><br><span class="line"><span class="comment">		3. had the key before.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pairNode&lt;K, E&gt;* currNode = firstNode, trailNode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (currNode != <span class="literal">nullptr</span> &amp;&amp; currNode-&gt;element.first &lt; thePair.first) &#123;</span><br><span class="line">		trailNode = currNode;</span><br><span class="line">		currNode = currNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currNode != <span class="literal">nullptr</span> &amp;&amp; currNode-&gt;element.first == thePair.first) &#123;</span><br><span class="line">		currNode-&gt;element.second = thePair.second; <span class="comment">// update</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pairNode&lt;K, E&gt;* newNode = <span class="keyword">new</span> pairNode(thePair, currNode);</span><br><span class="line">	<span class="keyword">if</span> (trailNode == <span class="literal">nullptr</span>) firstNode = newNode;</span><br><span class="line">	<span class="keyword">else</span> trailNode-&gt;next = newNode;</span><br><span class="line">	dictSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> sortedChain&lt;K, E&gt;::erase(<span class="keyword">const</span> K&amp; theKey)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Two situations:</span></span><br><span class="line"><span class="comment">		1. erase firstNode.</span></span><br><span class="line"><span class="comment">		2. not find.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pairNode&lt;K, E&gt;* currNode = firstNode, trailNode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (currNode != <span class="literal">nullptr</span> &amp;&amp; currNode-&gt;element.first &lt; theKey) &#123;</span><br><span class="line">		trailNode = currNode;</span><br><span class="line">		currNode = currNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currNode != <span class="literal">nullptr</span> &amp;&amp; currNode-&gt;element.first == theKey) &#123;</span><br><span class="line">		pairNode&lt;K, E&gt;* deleteNode = currNode;</span><br><span class="line">		<span class="keyword">if</span> (trailNode == <span class="literal">nullptr</span>) firstNode = currNode-&gt;next;</span><br><span class="line">		<span class="keyword">else</span> trailNode-&gt;next = currNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> currNode;</span><br><span class="line">		dictSize--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法习题答案(机械工业出版社)</category>
      </categories>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>鉴于自己在看机械工业出版社的数据结构时，常常苦于没有答案，便觉得有必要整理出一份自己的答案，虽然不一定完全正确，实现也不一定高效，但总有些参考价值叭。</p>
<a id="more"></a>
<h2 id="队列类的实现"><a href="#队列类的实现" class="headerlink" title="队列类的实现"></a>队列类的实现</h2><blockquote>
<p>队列的实现较为简单，我们给出具体的类，然后再讨论队列的习题。</p>
</blockquote>
<ul>
<li>纯虚基类<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>数组实现的队列<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总是要从别的文件粘贴栈过来好烦，用stl又不太正经</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PureBaseQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrayQueue</span> :</span> <span class="keyword">public</span> <span class="built_in">queue</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	arrayQueue(<span class="keyword">int</span> initialCapacity = <span class="number">20</span>);</span><br><span class="line">	~arrayQueue() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> theFront == theBack; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (theBack - theFront + arrayLength) % arrayLength; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* element;</span><br><span class="line">	<span class="keyword">int</span> theFront;</span><br><span class="line">	<span class="keyword">int</span> theBack;</span><br><span class="line">	<span class="keyword">int</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">arrayQueue&lt;T&gt;::arrayQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	arrayLength = initialCapacity;</span><br><span class="line">	theFront = theBack = <span class="number">0</span>;</span><br><span class="line">	element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; arrayQueue&lt;T&gt;::front() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (theFront == theBack)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	<span class="keyword">return</span> element[(theFront + <span class="number">1</span>) % arrayLength];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; arrayQueue&lt;T&gt;::back() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (theFront == theBack)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	<span class="keyword">return</span> element[theBack];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayQueue&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (theFront == theBack)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	theFront = (theFront + <span class="number">1</span>) % arrayLength;</span><br><span class="line">	element[theFront].~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> arrayQueue&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((theBack + <span class="number">1</span>) % arrayLength == theFront)</span><br><span class="line">	&#123;</span><br><span class="line">		T* newQueue = <span class="keyword">new</span> T[<span class="number">2</span> * arrayLength];</span><br><span class="line">		<span class="keyword">int</span> start = (theFront + <span class="number">1</span>) % arrayLength;</span><br><span class="line">		<span class="keyword">if</span> (start &lt; <span class="number">2</span>)</span><br><span class="line">			<span class="built_in">std</span>::copy(element + start, element + start + arrayLength - <span class="number">1</span>, newQueue);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::copy(element + start, element + arrayLength, newQueue);</span><br><span class="line">			<span class="built_in">std</span>::copy(element, element + theBack + <span class="number">1</span>, newQueue + arrayLength - start);</span><br><span class="line">		&#125;</span><br><span class="line">		theFront = <span class="number">2</span> * arrayLength - <span class="number">1</span>;</span><br><span class="line">		theBack = arrayLength - <span class="number">2</span>;</span><br><span class="line">		arrayLength *= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">delete</span>[]element;</span><br><span class="line">		element = newQueue;</span><br><span class="line">	&#125;</span><br><span class="line">	theBack = (theBack + <span class="number">1</span>) % arrayLength;</span><br><span class="line">	element[theBack] = theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>链表实现的队列<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created on Oct.23.2020 by Joe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PureBaseQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chainNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T element;</span><br><span class="line">	chainNode&lt;T&gt;* next;</span><br><span class="line">	chainNode() = <span class="keyword">default</span>;</span><br><span class="line">	chainNode(<span class="keyword">const</span> T&amp; theElement) : element(theElement) &#123;&#125;</span><br><span class="line">	chainNode(<span class="keyword">const</span> T&amp; theElement, chainNode&lt;T&gt;* theNext) : element(theElement), next(theNext) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linkedQueue</span> :</span> <span class="keyword">public</span> <span class="built_in">queue</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	linkedQueue(<span class="keyword">int</span> initialCapacity = <span class="number">20</span>);</span><br><span class="line">	~linkedQueue();</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> queueSize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> queueSize; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	chainNode&lt;T&gt;* theFront;</span><br><span class="line">	chainNode&lt;T&gt;* theBack;</span><br><span class="line">	<span class="keyword">int</span> queueSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedQueue&lt;T&gt;::linkedQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">	theFront = theBack = <span class="literal">nullptr</span>;</span><br><span class="line">	queueSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">linkedQueue&lt;T&gt;::~linkedQueue()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (theFront != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt;* nextNode = theFront-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> theFront;</span><br><span class="line">		theFront = nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; linkedQueue&lt;T&gt;::front() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	<span class="keyword">return</span> theFront-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; linkedQueue&lt;T&gt;::back() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	<span class="keyword">return</span> theBack-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedQueue&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	chainNode&lt;T&gt;* nextNode = theFront-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> theFront;</span><br><span class="line">	theFront = nextNode;</span><br><span class="line">	queueSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> linkedQueue&lt;T&gt;::push(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	chainNode&lt;T&gt;* newNode = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (queueSize == <span class="number">0</span>)</span><br><span class="line">		theFront = theBack = newNode;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		theBack-&gt;next = newNode;</span><br><span class="line">		theBack = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	queueSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法习题答案(机械工业出版社)</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown介绍</title>
    <url>/2020/11/15/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/markdown/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="MarkDown编辑代码块"><a href="#MarkDown编辑代码块" class="headerlink" title="MarkDown编辑代码块"></a>MarkDown编辑代码块</h2>]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
  </entry>
  <entry>
    <title>主定理的应用</title>
    <url>/2020/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E4%B8%BB%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="何为主定理"><a href="#何为主定理" class="headerlink" title="何为主定理?"></a>何为主定理?</h2><ul>
<li><input disabled="" type="checkbox"> Wikipedia对主定理的描述是:它提供了渐进大O表示许多由分治法得到的递推式的方法。详细介绍可以参考算法导论。<blockquote>
<p>Tips: 不是所有递推关系式都可以用主定理。</p>
</blockquote>
<a id="more"></a>

</li>
</ul>
<h2 id="主定理通常的应用情形"><a href="#主定理通常的应用情形" class="headerlink" title="主定理通常的应用情形"></a>主定理通常的应用情形</h2><ul>
<li>假设有递推式:<br>$$ T(n) = aT(\dfrac {n}{b})+f(n), 其中a\geq1, b&gt;1 $$<br>其中，n是问题的规模，a为子问题数量，\dfrac {n}{b}为每个子问题的规模, f(n)是除递归外额外的工作。那么主定理通常有以下形式:<table>
<thead>
<tr>
<th>递推关系式</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>$$T(n) = T(\dfrac {n}{2}) + \varTheta(1)$$</td>
<td>$$\varTheta(\log n)$$</td>
</tr>
<tr>
<td>$$T(n) = 2T(\dfrac {n}{2}) + \varTheta(1)$$</td>
<td>$$\varTheta(n)$$</td>
</tr>
<tr>
<td>$$T(n) = 2T(\dfrac {n}{2}) + O(\log n)$$</td>
<td>$$\varTheta(n)$$</td>
</tr>
<tr>
<td>$$T(n) = 2T(\dfrac {n}{2}) + \varTheta(n)$$</td>
<td>$$\varTheta(n\log n)$$</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="参考文献和资料"><a href="#参考文献和资料" class="headerlink" title="参考文献和资料"></a>参考文献和资料</h2><ul>
<li>Wikipedia，2020年10月12日更新版。</li>
<li>算法导论。</li>
<li>Michael T. Goodrich and Roberto Tamassia. Algorithm Design: Foundation, Analysis, and Internet Examples. Wiley, 2002. ISBN 0-471-38365-1. The master theorem (including the version of Case 2 included here, which is stronger than the one from CLRS) is on pp. 268–270.</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法习题答案(机械工业出版社)</category>
      </categories>
  </entry>
  <entry>
    <title>Latex介绍</title>
    <url>/2020/11/15/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91/latex/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>文本编辑工具</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划专题</title>
    <url>/2020/11/18/ACM/acm-dp%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ACM专题</category>
      </categories>
  </entry>
  <entry>
    <title>周赛总结</title>
    <url>/2020/11/18/ACM/%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ACM专题</category>
      </categories>
  </entry>
  <entry>
    <title>2020年11月24日题单</title>
    <url>/2020/11/24/ACM/%E4%B8%AA%E4%BA%BA%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<p>此题单于2020年11月24日整理，题解来自刘汝佳原书源码或者个人解法，不一定是很好的实现。</p>
<a id="more"></a>
<h2 id="ACM入门题，STL的应用"><a href="#ACM入门题，STL的应用" class="headerlink" title="ACM入门题，STL的应用"></a>ACM入门题，STL的应用</h2><ul>
<li><p><input disabled="" type="checkbox">  题单列表</p>
</li>
<li><p>排序+检索STL</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>大理石在哪儿</td>
<td><a href="https://ac.nowcoder.com/acm/problem/116088"><strong>UVa10474</strong></a></td>
</tr>
</tbody></table>
</li>
<li><p>vector的应用</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>木块问题</td>
<td><a href="https://ac.nowcoder.com/acm/problem/113954"><strong>UVa101</strong></a></td>
</tr>
</tbody></table>
</li>
<li><p>set的应用</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>安迪的第一个字典</td>
<td><a href="https://ac.nowcoder.com/acm/problem/116429"><strong>UVa10815</strong></a></td>
</tr>
</tbody></table>
</li>
<li><p>map的应用</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>反片语</td>
<td><a href="https://ac.nowcoder.com/acm/problem/114009"><strong>UVa156</strong></a></td>
</tr>
</tbody></table>
</li>
<li><p>stack、queue、priority_queue的应用</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>集合栈计算机</td>
<td><a href="https://ac.nowcoder.com/acm/problem/117710"><strong>UVa12096</strong></a></td>
</tr>
<tr>
<td>团体队列</td>
<td><a href="https://ac.nowcoder.com/acm/problem/114393"><strong>UVa540</strong></a></td>
</tr>
<tr>
<td>丑数</td>
<td><a href="https://ac.nowcoder.com/acm/problem/113989"><strong>UVa136</strong></a></td>
</tr>
</tbody></table>
</li>
<li><p><input disabled="" type="checkbox">  题解</p>
</li>
<li><p>大理石在哪儿</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q) == <span class="number">2</span> &amp;&amp; n &amp;&amp; q)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CASE# %d:\n&quot;</span>, ++kase);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">        sort(p,p+n);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(p,p+n,x)-p;</span><br><span class="line">            <span class="keyword">if</span>(pos == n || p[pos] != x) <span class="built_in">printf</span>(<span class="string">&quot;%d not found\n&quot;</span>, x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d found at %d\n&quot;</span>, x, pos+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>木块问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_blocks</span><span class="params">(<span class="keyword">int</span> e,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">0</span>;x &lt; n;x++)</span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>;y &lt; p[x].size();y++)</span><br><span class="line">            <span class="keyword">if</span>(p[x][y] == e) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_blocks</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h = y+<span class="number">1</span>;h &lt; p[x].size();h++)</span><br><span class="line">        p[p[x][h]].push_back(p[x][h]);</span><br><span class="line">    p[x].resize(y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pile_blocks</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> y,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h = y;h &lt; p[a].size();h++)</span><br><span class="line">        p[b].push_back(p[a][h]);</span><br><span class="line">    p[a].resize(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_blocks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; p[i].size();j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i][j]; <span class="comment">// 格式控制</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">string</span> w1,w2;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) p[i].push_back(i);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; w1 &gt;&gt; a &gt;&gt; w2 &gt;&gt; b)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        find_blocks(a,x1,y1);</span><br><span class="line">        find_blocks(b,x2,y2);</span><br><span class="line">        <span class="keyword">if</span>(x1 == x2) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(w1 == <span class="string">&quot;move&quot;</span>) remove_blocks(x1,y1);</span><br><span class="line">        <span class="keyword">if</span>(w2 == <span class="string">&quot;onto&quot;</span>) remove_blocks(x2,y2);</span><br><span class="line">        pile_blocks(x1,y1,x2);</span><br><span class="line">    &#125;</span><br><span class="line">    print_blocks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>安迪的第一个字典</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; dict;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s,buf;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i])) s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> s[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; buf) dict.insert(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = dict.begin();it != dict.end();++it) <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 反片语</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">re_expr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ans[i])) ans[i] = <span class="built_in">tolower</span>(ans[i]);</span><br><span class="line">    sort(ans.begin(),ans.end());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        input.push_back(s);</span><br><span class="line">        <span class="built_in">string</span> r = re_expr(s);</span><br><span class="line">        <span class="keyword">if</span>(!cnt.count(r)) cnt[r] = <span class="number">0</span>;</span><br><span class="line">        cnt[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; input.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[re_expr(input[i])] == <span class="number">1</span>)</span><br><span class="line">            ans.push_back(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>集合栈计算器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxQ = <span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;C:\\Users\\XUWL\\Desktop\\out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t) == <span class="number">1</span> &amp;&amp; t)&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; qId;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n,x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">            <span class="keyword">while</span>(n--) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); qId[x] = i;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d\n&quot;</span>, ++kase);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q,q2[maxQ];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">            <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = q.front();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q2[t].front()); q2[t].pop();</span><br><span class="line">                <span class="keyword">if</span>(q2[t].empty()) q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                <span class="keyword">int</span> t = qId[x];</span><br><span class="line">                <span class="keyword">if</span>(q2[t].empty()) q.push(t);</span><br><span class="line">                q2[t].push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>丑数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;ll&gt; in;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;ll,<span class="built_in">vector</span>&lt;ll&gt;,greater&lt;ll&gt;&gt; ugly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> coeff[<span class="number">3</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ugly.push(<span class="number">1</span>); in.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;;i++)&#123;</span><br><span class="line">    	ll t = ugly.top(); ugly.pop();</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1500</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The 1500\&#x27;th ugly number is &quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">        	ll x2 = t*coeff[j];</span><br><span class="line">        	<span class="keyword">if</span>(!in.count(x2)) &#123;in.insert(x2); ugly.push(x2);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精"><a href="#高精" class="headerlink" title="高精"></a>高精</h2></li>
</ul>
<ul>
<li>参考:算法竞赛入门经典，刘汝佳，第二版。</li>
</ul>
]]></content>
      <categories>
        <category>ACM专题</category>
      </categories>
  </entry>
  <entry>
    <title>我会采更多的雏菊</title>
    <url>/2020/11/18/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/%E6%88%91%E4%BC%9A%E9%87%87%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%9B%8F%E8%8F%8A/</url>
    <content><![CDATA[<h2 id="我会采更多的雏菊"><a href="#我会采更多的雏菊" class="headerlink" title="我会采更多的雏菊"></a><strong>我会采更多的雏菊</strong></h2><ul>
<li>纳·斯代尔<a id="more"></a>

</li>
</ul>
<p>如果我能够从头活过，<br>我会试着犯更多的错。 </p>
<p>我会放松一点，我会灵活一点。<br>我会比这一趟过得傻。<br>很少有什么事情能让我当真。 </p>
<p>我会疯狂一些，我会少讲点卫生。<br>我会冒更多的险。我会更经常的旅行。<br>我会爬更多的山，游更多的河，看更多的日落。<br>我会多吃冰激凌，少吃豆子。<br>我会惹更多的麻烦，可是不在想象中担忧。 </p>
<p>你看，我小心翼翼地稳健地理智地活着。<br>一个又一个小时，一天又一天。 </p>
<p>噢，我有过难忘的时刻。<br>如果我能够重来一次，我会要更多这样的时刻。 </p>
<p>事实上，我不需要别的什么，<br>仅仅是时刻，一个接着一个。<br>而不是每天都操心着以后的漫长日子。 </p>
<p>我曾经不论到哪里都不忘记带上：<br>温度计，热水壶，雨衣和降落伞。 </p>
<p>如果我能够重来一次，<br>我会到处走走，什么都试试，并且轻装上阵。<br>如果我能够重头活过，<br>我会延长打赤脚的时光。<br>从尽早的春天到尽晚的秋天。 </p>
<p>我会更经常的逃学。<br>我不会考那么高的分数，除非是一不小心。<br>我会多骑些旋转木马，<br>我会采更多的雏菊。</p>
<ul>
<li><strong>我也会采更多的雏菊</strong><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=506094660&auto=1&height=66"></iframe></li>
</ul>
]]></content>
      <categories>
        <category>记录生活</category>
      </categories>
  </entry>
  <entry>
    <title>构造函数成员初始化顺序</title>
    <url>/2020/11/13/C++%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82/%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="构造函数里的成员初始化顺序"><a href="#构造函数里的成员初始化顺序" class="headerlink" title="构造函数里的成员初始化顺序"></a>构造函数里的成员初始化顺序</h2><a id="more"></a>
<ul>
<li>我们以一个案例开头<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	X(<span class="keyword">int</span> val) : j(val),i(j) &#123; &#125; <span class="comment">// undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++类构造函数初始化成员时，顺序与该成员在类中出现的顺序一致，这也就是说，上面的类中<br>，即使构造函数初值列表中貌似时j先被初始化，实际上编译器先初始化了i，此时j未确定，会产生未定义的结果。</li>
<li>g++下编译给出如下警告:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;xxx&#x27;</span> will be initialized after [-Wreorder].</span><br></pre></td></tr></table></figure></li>
<li>g++下生成汇编:<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">	.file</span>	<span class="string">&quot;class.cpp&quot;</span></span><br><span class="line"><span class="meta">	.text</span></span><br><span class="line"><span class="meta">	.section</span> .rdata,<span class="string">&quot;dr&quot;</span></span><br><span class="line"><span class="symbol">_ZStL19piecewise_construct:</span></span><br><span class="line"><span class="meta">	.space</span> <span class="number">1</span></span><br><span class="line"><span class="meta">.lcomm</span> _ZStL8__ioinit,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"><span class="meta">	.section</span>	.text$_ZN1XC1Ei,<span class="string">&quot;x&quot;</span></span><br><span class="line"><span class="meta">	.linkonce</span> discard</span><br><span class="line"><span class="meta">	.align</span> <span class="number">2</span></span><br><span class="line"><span class="meta">	.globl</span>	_ZN1XC1Ei</span><br><span class="line"><span class="meta">	.def</span>	_ZN1XC1Ei<span class="comment">;	.scl	2;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.seh_proc</span>	_ZN1XC1Ei</span><br><span class="line"><span class="symbol">_ZN1XC1Ei:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="meta">	.seh_pushreg</span>	%rbp</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="meta">	.seh_setframe</span>	%rbp, <span class="number">0</span></span><br><span class="line"><span class="meta">	.seh_endprologue</span></span><br><span class="line">	<span class="keyword">movq</span>	%rcx, <span class="number">16</span>(%rbp)</span><br><span class="line">	movl	%edx, <span class="number">24</span>(%rbp)</span><br><span class="line">	<span class="keyword">movq</span>	<span class="number">16</span>(%rbp), %rax</span><br><span class="line">	movl	<span class="number">4</span>(%rax), %edx</span><br><span class="line">	<span class="keyword">movq</span>	<span class="number">16</span>(%rbp), %rax</span><br><span class="line">	movl	%edx, (%rax)</span><br><span class="line">	<span class="keyword">movq</span>	<span class="number">16</span>(%rbp), %rax</span><br><span class="line">	movl	<span class="number">24</span>(%rbp), %edx</span><br><span class="line">	movl	%edx, <span class="number">4</span>(%rax)</span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	popq	%rbp</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="meta">	.seh_endproc</span></span><br><span class="line"><span class="meta">	.def</span>	__main<span class="comment">;	.scl	2;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.text</span></span><br><span class="line"><span class="meta">	.globl</span>	main</span><br><span class="line"><span class="meta">	.def</span>	main<span class="comment">;	.scl	2;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.seh_proc</span>	main</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="meta">	.seh_pushreg</span>	%rbp</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="meta">	.seh_setframe</span>	%rbp, <span class="number">0</span></span><br><span class="line">	subq	<span class="number">$48</span>, %rsp</span><br><span class="line"><span class="meta">	.seh_stackalloc</span>	<span class="number">48</span></span><br><span class="line"><span class="meta">	.seh_endprologue</span></span><br><span class="line">	<span class="keyword">call</span>	__main</span><br><span class="line">	leaq	-<span class="number">8</span>(%rbp), %rax</span><br><span class="line">	movl	<span class="number">$3</span>, %edx</span><br><span class="line">	<span class="keyword">movq</span>	%rax, %rcx</span><br><span class="line">	<span class="keyword">call</span>	_ZN1XC1Ei</span><br><span class="line">	movl	<span class="number">$0</span>, %eax</span><br><span class="line">	addq	<span class="number">$48</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="meta">	.seh_endproc</span></span><br><span class="line"><span class="meta">	.def</span>	__tcf_0<span class="comment">;	.scl	3;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.seh_proc</span>	__tcf_0</span><br><span class="line"><span class="symbol">__tcf_0:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="meta">	.seh_pushreg</span>	%rbp</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="meta">	.seh_setframe</span>	%rbp, <span class="number">0</span></span><br><span class="line">	subq	<span class="number">$32</span>, %rsp</span><br><span class="line"><span class="meta">	.seh_stackalloc</span>	<span class="number">32</span></span><br><span class="line"><span class="meta">	.seh_endprologue</span></span><br><span class="line">	leaq	_ZStL8__ioinit(%rip), %rcx</span><br><span class="line">	<span class="keyword">call</span>	_ZNSt8ios_base4InitD1Ev</span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	addq	<span class="number">$32</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="meta">	.seh_endproc</span></span><br><span class="line"><span class="meta">	.def</span>	_Z41__static_initialization_and_destruction_0ii<span class="comment">;	.scl	3;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.seh_proc</span>	_Z41__static_initialization_and_destruction_0ii</span><br><span class="line"><span class="symbol">_Z41__static_initialization_and_destruction_0ii:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="meta">	.seh_pushreg</span>	%rbp</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="meta">	.seh_setframe</span>	%rbp, <span class="number">0</span></span><br><span class="line">	subq	<span class="number">$32</span>, %rsp</span><br><span class="line"><span class="meta">	.seh_stackalloc</span>	<span class="number">32</span></span><br><span class="line"><span class="meta">	.seh_endprologue</span></span><br><span class="line">	movl	%ecx, <span class="number">16</span>(%rbp)</span><br><span class="line">	movl	%edx, <span class="number">24</span>(%rbp)</span><br><span class="line">	cmpl	<span class="number">$1</span>, <span class="number">16</span>(%rbp)</span><br><span class="line">	<span class="keyword">jne</span>	.L7</span><br><span class="line">	cmpl	<span class="number">$65535</span>, <span class="number">24</span>(%rbp)</span><br><span class="line">	<span class="keyword">jne</span>	.L7</span><br><span class="line">	leaq	_ZStL8__ioinit(%rip), %rcx</span><br><span class="line">	<span class="keyword">call</span>	_ZNSt8ios_base4InitC1Ev</span><br><span class="line">	leaq	__tcf_0(%rip), %rcx</span><br><span class="line">	<span class="keyword">call</span>	atexit</span><br><span class="line"><span class="symbol">.L7:</span></span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	addq	<span class="number">$32</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="meta">	.seh_endproc</span></span><br><span class="line"><span class="meta">	.def</span>	_GLOBAL__sub_I_main<span class="comment">;	.scl	3;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.seh_proc</span>	_GLOBAL__sub_I_main</span><br><span class="line"><span class="symbol">_GLOBAL__sub_I_main:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line"><span class="meta">	.seh_pushreg</span>	%rbp</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rbp</span><br><span class="line"><span class="meta">	.seh_setframe</span>	%rbp, <span class="number">0</span></span><br><span class="line">	subq	<span class="number">$32</span>, %rsp</span><br><span class="line"><span class="meta">	.seh_stackalloc</span>	<span class="number">32</span></span><br><span class="line"><span class="meta">	.seh_endprologue</span></span><br><span class="line">	movl	<span class="number">$65535</span>, %edx</span><br><span class="line">	movl	<span class="number">$1</span>, %ecx</span><br><span class="line">	<span class="keyword">call</span>	_Z41__static_initialization_and_destruction_0ii</span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	addq	<span class="number">$32</span>, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="meta">	.seh_endproc</span></span><br><span class="line"><span class="meta">	.section</span>	.ctors,<span class="string">&quot;w&quot;</span></span><br><span class="line"><span class="meta">	.align</span> <span class="number">8</span></span><br><span class="line"><span class="meta">	.quad</span>	_GLOBAL__sub_I_main</span><br><span class="line"><span class="meta">	.ident</span>	<span class="string">&quot;GCC: (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project) 8.1.0&quot;</span></span><br><span class="line"><span class="meta">	.def</span>	_ZNSt8ios_base4InitD1Ev<span class="comment">;	.scl	2;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.def</span>	_ZNSt8ios_base4InitC1Ev<span class="comment">;	.scl	2;	.type	32;	.endef</span></span><br><span class="line"><span class="meta">	.def</span>	atexit<span class="comment">;	.scl	2;	.type	32;	.endef</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++细节</category>
      </categories>
  </entry>
  <entry>
    <title>ACM</title>
    <url>/2020/11/22/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/acm%E5%85%A5%E9%98%9F/</url>
    <content><![CDATA[<h2 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h2><a id="more"></a>
<p>很早就想打ACM了，其实是因为长期以来的颓废、盲目和人际交往上的压力让我不得不去找点事做。ACM是不二之选。<br>我也愿意投入很长很长的时间去学习、去提高。<br>当然，我深知自己已然不可能成为TopCoder，因为当我还在迷茫的时候，早就有无数像我一样热爱的人们踏上了他们的征途。<br>我也没想过夺金，只希望能够不留遗憾吧。<br>第一次接触编程，大概是在2019年年底，更确切地说，开始接触代码是在2020年二月，中途也断过几个月。八个月以来，其实自己并没有学很多东西，就算学了也不深入，因为自己不确定学的东西是不是有用，尤其是当自己看到一些可能用不到的算法的时候。最开始接触到的语言是C语言，起初我以为学完一门语言，就能做出任何想做的东西(新手的幼稚想法)。后来慢慢接触了C++语言，这也是我目前用的最多的语言啦!五月份到八月份还零星地学了些Python和Js。我并不是个智力很好的人，我在初中高中时也并没有很出彩，大多时候都是靠时间叠经验。高二的时候常听见背后有人说我只会学习，当时感觉很难受，于是在紧张的高二暑假我还跑去学了吉他。高三的时候又迷恋上了羽毛球，几乎一有时间就去打。大家的议论确实改变了我的行为。但那只是从前，现在绝对不可能了。前几天看见高中的同学(如果你看见了的话我还是得对高中说过的话感到抱歉)说进了大学就变了个人了，我实在不能更认同她的话了。但是我确实一直在追求着喜欢的事情，这点让我很骄傲(即使越来越多的人渐渐疏远了)。<br>我在高中有过两段情感经历(很难去直面自己的错误)。因为错误的处理方式和表达，我几乎是犯下了最让人痛恨的错误(起码我这么认为)。去年暑假我最好最好的朋友在少林寺下山的路上突然问我这件事，我矢口否认并且尽快逃避了全部的问题。我是真的很抱歉，我也不知道我为什么是那样子的人，我也很胆小不敢面对错误。在那之后我也特别敏感。四月份的时候好朋友开玩笑似地对我说他和学姐谈恋爱了，我惊喜地跑出去和他打电话，还说要对他好一点，他的那句”要你教我做事”让我很羞愧。我确实没有资格。这一年一直在为自己的行为负责，不可避免地失去很多原本的好朋友。我有个日历，上面写着每个好朋友地生日。从某天开始，我最好的朋友似乎就和我断了联系，我很抱歉，真的很抱歉，我不知道怎么做。时间一长，我开始怀疑自己的资格和人品。八月买了一支Picasso的钢笔，在珠海写了一封信，我想生日那天肯定可以好好地说说自己的想法(因为实在是压抑太久了)。但是当日历到达他生日地那一天，我却不敢说些什么。<br>同样的事情在这两个月发生了好几次。我越来越不能确定我在大家(我所认为的重要的人)眼里的分量了。有段时间好像很抑郁，但是还是得压抑着发很多coding动态，显得自己过得很好很积极向上，其实过的很糟糕，生活很糟糕，心情也很糟糕，天气也很糟糕。因为我确实没有资格矫情，去年的这个时候，有人因为我也抑郁了很久吧。我只是自作自受罢了。确实想念好朋友了，希望在西安过得好而且多认识些值得的新朋友。<br>对所有我的奇怪，偏执，坏人品伤害到的人说抱歉啦，毕竟博客也有500浏览量了也并不少了。<br>以后决心好好打ACM了，我得找到一个能让我一直做下去，让我忙到忘记烦恼的事业。这两天的小排位赛一次RANK1，一次RANK3+3次first blood也鼓励了自己。另外也希望队友多多加油未来可期。一年后(最多两年后)希望站在CCPC某赛区的领奖台上，拿到一块银牌，这样自己也不会有遗憾了。<br>啊对，以后会回去当高中老师，希望可以和大家一起加油。</p>
]]></content>
      <categories>
        <category>记录生活</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript基础知识</title>
    <url>/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Javascript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搭建一个小型博客需要的前导知识</category>
      </categories>
  </entry>
  <entry>
    <title>CSS基础知识</title>
    <url>/2020/11/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/CSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搭建一个小型博客需要的前导知识</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
